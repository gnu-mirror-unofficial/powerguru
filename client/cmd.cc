// 
// Copyright (C) 2005, 2006 - 2018
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <thread>
#include <mutex>
#include <queue>
#include <condition_variable>
#include <boost/asio.hpp>
#include "tcpip.h"
#include "console.h"
#include "msgs.h"
#include "log.h"
#include "tcpip.h"
#include "ownet.h"

static void usage (const char *);

const int INBUFSIZE = 1024;
extern void daemon_handler(boost::asio::ip::tcp::socket &sock);
extern void console_handler(boost::asio::ip::tcp::socket &sock);
extern void damn_handler(boost::asio::ip::tcp::socket &sock);

using namespace boost::asio;
using namespace boost::asio::ip;

std::mutex queue_lock;
std::queue <XML> tqueue;
std::condition_variable queue_cond;

int
main(int argc, char *argv[])
{
    int         c;
    std::string dbhost = "localhost";
    std::string pserver = "pi";
    retcode_t   ret;

    log_init("pguru");
    // scan for the two main standard GNU options
    for (c=0; c<argc; c++) {
        if (strcmp("--help", argv[c]) == 0) {
            usage(argv[0]);
            exit(0);
        }
        if (strcmp("--version", argv[c]) == 0) {
            std::cerr << "PowerGuru version: " << VERSION << std::endl;
            exit(0);
        }
    }
    
    while ((c = getopt (argc, argv, "hvVd:p:")) != -1) {
        switch (c) {
          case 'h':
              usage (argv[0]);
              break;
        
          case 'v':
              //dbglogfile.set_verbosity();
              break;
        
          case 'd':
              dbhost = strdup(optarg);
              break;
        
          case 'p':
              pserver = strdup(optarg);
              break;

          case 'V':
              std::cerr << "PowerGuru version " << VERSION << std::endl;
              exit (0);
              break;   
        
          default:
              usage (argv[0]);
              break;
        }
    }

     // Connect to the PowerGuru daemon. Note that this is currently
    // only allows a single connection at a time.
#if 1
    boost::asio::io_service ioservice;
    tcp::resolver       resolver{ioservice};
    tcp::resolver::query query{tcp::v4(), pserver, "7654"};
    tcp::resolver::iterator iterator = resolver.resolve(query);
    tcp::socket         tcp_socket{ioservice};
    boost::system::error_code error;
    try {
        boost::asio::connect(tcp_socket, iterator);
    } catch (const std::exception& e) {
        BOOST_LOG_SEV(lg, severity_level::error)
            << "Couldn't connect to PowerGuru server! " << e.what();
        exit(-1);
    }
    ioservice.run();
#else
    // New API, not supported by Raspbian
    boost::asio::io_context io_context;
    tcp::resolver resolver(io_context);
    tcp::resolver::results_type endpoints =
        resolver.resolve(tcp::v4(),pserver, "7654");
    tcp::socket tcp_socket(io_context);
    boost::asio::connect(tcp_socket, endpoints);
#endif

    std::thread daemon_thread (daemon_handler, std::ref(tcp_socket));

    std::thread console_thread (console_handler, std::ref(tcp_socket));

#if 0
    // Commands from the client via the client_handler get processed here
    // so messages can be passed between threads.
    while (true) {
        std::unique_lock<std::mutex> guard(queue_lock);
        queue_cond.wait(guard, [] { return !tqueue.empty(); });
        XML xml = tqueue.front();
        tqueue.pop();
        // if (xml[0]->nameGet() == "list") {
            std::vector<std::string> devs;
            //ownet.listDevices(devs);
            //std::vector<std::string>::iterator sit;
            //for (sit = devs.begin(); sit != devs.end(); sit++) {
            std::cerr << "FIXME: " << xml[0]->nameGet() <<std::endl;
            //}
    }
#endif

    daemon_thread.join();                // pauses until second finishes
    console_thread.join();                // pauses until second finishes

#ifdef BUILD_OWNET
    //third.join();                // pauses until second finishes
#endif

}

static void
usage (const char *prog)
{
    std::cerr << "This is a simple command line for the PowerGuru daemon." << std::endl;
    std::cerr << "Usage: pguru: [h] filename" << std::endl;
    std::cerr << "-h\tHelp" << std::endl;
    std::cerr << "-v\tVerbose output" << std::endl;
    std::cerr << "-d\tDatabase Host(localhost)" << std::endl;
    std::cerr << "-p\tPowerguru Host(localhost)" << std::endl;
    exit (-1);
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
