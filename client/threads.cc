// 
// Copyright (C) 2018, 2019 Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

/// \copyright GNU Public License.
/// \file threads.cc Threaded event handlers for all client side I/O 

#ifdef HAVE_CONFIG_H
// This is generated by autoconf.
# include "config.h"
#endif

#include <sys/select.h>
#include <cstring>
#include <vector>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <sstream>
#include <signal.h>
#include <errno.h>
#include <thread>
#include <condition_variable>
#include <mutex>
#include <chrono>
#include <boost/asio.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/write.hpp>
#include <boost/asio/buffer.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/posix_time/posix_time_io.hpp>
#include <iostream>
#include "log.h"
#include "ownet.h"
#include "console.h"
#include "database.h"
#include "xml.h"
#include "commands.h"

using namespace std::chrono_literals;
using namespace boost::asio;
using namespace boost::asio::ip;
#include <boost/system/error_code.hpp>
using namespace boost::system;

// This queue is used to pass data between the threads.
extern std::mutex queue_lock;
extern std::queue <XML> tqueue;
extern std::condition_variable queue_cond;

void
console_handler(boost::asio::ip::tcp::socket &tcp_socket)
{
     DEBUGLOG_REPORT_FUNCTION;

    // This is the main command loop for user input. Commands in
    // a simple XML format, but for the user simple text strings
    // are used.
    int loop = true;
    std::string line;
    Commands cmd;
    std::string args;
    
    std::string str;
    while(loop) {
        // Don't eat up all the cpu cycles!
        while(std::cin) {
            std::string action;
            args.erase();
            std::getline(std::cin, line);
            // The command is the first part of the string inputted,
            // with optional arguments following.
            size_t pos = line.find(' ');
            if (pos != line.size() && pos != std::string::npos) {
                action = line.substr(0, pos);
                args = line.substr(pos, line.size());
            } else {
                action = line;
            }
            cmd.createCommand(cmd.convertAction(action), args, str);

            boost::system::error_code error;
            boost::asio::write(tcp_socket, buffer(str), error);
        }
    }
}

void
daemon_handler(boost::asio::ip::tcp::socket &tcp_socket)
{
    DEBUGLOG_REPORT_FUNCTION;

    boost::system::error_code ret;
    boost::asio::io_service ioservice;
    tcp::resolver       resolv{ioservice};
    std::array<char, 1024> bytes;
    std::memset(bytes.data(), 0, bytes.size());
    Commands cmd;
    bool loop = true;
    int retries = 10;
    while (retries-- > 0) {
        boost::system::error_code error;
        // Send a HELO message to the server to authenticate
        std::string str;
        std::string args = boost::asio::ip::host_name();
        args += " ";
        args += std::getenv("USER");
        cmd.createCommand(Commands::HELO, args, str);
        try {
            boost::asio::write(tcp_socket, buffer(str), error);
        } catch (const std::exception& e) {
            BOOST_LOG_SEV(lg, severity_level::error)
                << "Couldn't write data to PowerGuru server! " << e.what();
            exit(-1);
        }   
        while (loop) {
            try {
                tcp_socket.read_some(buffer(bytes), error);
            } catch (const std::exception& e) {
                BOOST_LOG_SEV(lg, severity_level::error)
                    << "Couldn't read data from PowerGuru server! " << e.what();
                exit(-1);
            }
            // if the first character is a <, assume it's in XML formst.
            str = bytes.data();
            if (bytes[0] == '<') {
                XML xml;
                // the data buffer is padded with zeros, so we can safely convert
                // it to a string as it'll be null terminated. Since the network
                // protocol is XML based, we know it'll always be ASCII.
                xml.parseMem(str);
                //BOOST_LOG(lg) << "FIXME1: \"" << xml.nameGet() << "\"";
                if (xml.nameGet() == "command") {
                    //std::cerr << "FIXME2: Command: " << xml.valueGet() << std::endl;
                    if (xml.valueGet() == "help") {
                        boost::asio::write(tcp_socket, buffer("Hello World!\n"), error);
                    }
                } else if (xml.nameGet() == "data") {
                    std::cerr << "FIXME: DATA: " << xml.valueGet() << std::endl;
                } else {
                    std::cerr << "FIXME: JUNK: " << xml.nameGet() << std::endl;
                    std::cerr << "FIXME: JUNK: " << xml.valueGet() << std::endl;
                }
                //xml.dump();
            } else {
                std::cerr << str << std::endl;
            }
        }
    }
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
