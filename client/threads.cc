// 
// Copyright (C) 2018 Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

#ifdef HAVE_CONFIG_H
// This is generated by autoconf.
# include "config.h"
#endif

#include <cstring>
#include <vector>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <sstream>
#include <signal.h>
#include <errno.h>
#include <thread>
#include <condition_variable>
#include <mutex>
#include <chrono>

#ifdef HAVE_GETOPT_H
#include <getopt.h>
#else
extern int optind;
extern char *optarg;
#endif

#include "log.h"
#include "ownet.h"
#include "console.h"
#include "database.h"
#include "tcpip.h"
#include "xml.h"
#include "commands.h"

extern LogFile dbglogfile;

using namespace std::chrono_literals;

void
console_handler(Tcpip &net)
{
     DEBUGLOG_REPORT_FUNCTION;    

    // This is the main command loop for user input. Commands in
    // a simple XML format, but for the user simple text strings
    // are used.
    int loop = true;
    std::string line;
    Commands cmd;

    // Send a HELO message to the server so it knows who we are
    std::string args;
    std::string str;
    args = net.getHostname();
    args += " ";
    args += std::getenv("USER");
    cmd.createCommand(Commands::HELO, args, str);
    net.writeNet(str);
    
    while(loop) {
        // Don't eat up all the cpu cycles!
        while(std::cin) {
            std::string action;
            args.erase();
            std::getline(std::cin, line);
            // The command is the first part of the string inputted,
            // with optional arguments following.
            size_t pos = line.find(' ');
            if (pos != line.size() && pos != std::string::npos) {
                action = line.substr(0, pos);
                args = line.substr(pos, line.size());
            } else {
                action = line;
            }
            cmd.createCommand(cmd.convertAction(action), args, str);
            net.writeNet(str);
        }
    }
}

void
daemon_handler(Tcpip &net)
{
    DEBUGLOG_REPORT_FUNCTION;

    retcode_t ret;
    int retries = 10;

    //net.createNetClient(DEFAULTPORT);

    //net.writeNet("Hello World!\r\n");

    while (retries-- > 0) {
        bool loop = true;
        std::vector<unsigned char> data;
        while (loop) {
            data.clear();
            if (net.readNet(data).size() < 0) {
                dbglogfile << "ERROR: Got error from socket " << std::endl;
                loop = false;
            } else {
                if (data.data() == 0) {
                    continue;
                }
                // Store the pointer to the data to make the code easier to read.
                std::string buffer = (char *)data.data();
                // Check to see if the socket was closed, so the read failed.
                if (buffer[0] == 255) {
                    std::cerr << "Done!!!!" << std::endl;
                    loop = false;
                    retries = 0;
                    break;
                }                
                //if (buffer.size() == 1 && *data.data() == 0) {
                if (data.size() == 1 && buffer[0] == 0) {
                    net.closeConnection();
                    // loop = false;
                    break;
                }
                if (data.size() == 0) {
                    sleep(1);
                    continue;
                }
                size_t pos = buffer.find('\n');
                if (pos == 0 || pos == std::string::npos) {
                    data.clear();
                    buffer.clear();
                    loop = false;
                    continue;
                }
                buffer.erase(pos);
                // if the first character is a <, assume it's in XML formst.
                if (buffer[0] == '<') {
                    XML xml;
                    xml.parseMem(buffer);
                    dbglogfile << "FIXME1: \"" << xml.nameGet() << "\"" << std::endl;
                    if (xml.nameGet() == "command") {
                        std::cerr << "FIXME2: Command: " << xml.valueGet() << std::endl;
                        if (xml.valueGet() == "help") {
                            net.writeNet("Hello World!\n");
                        }
                        
                    } else if (xml.nameGet() == "data") {
                        std::cerr << "FIXME: DATA: " << xml.valueGet() << std::endl;
                    } else {
                        std::cerr << "FIXME: JUNK: " << xml.valueGet() << std::endl;
                    }
                } else {
                    std::cerr << buffer << std::endl;
                }
            }
        }
    }

    net.closeNet();
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
