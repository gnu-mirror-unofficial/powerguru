// 
// Copyright (C) 2005, 2006 - 2018      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netdb.h>
#include <unistd.h>
#include <iostream>
#ifndef SIOCGIFCONF
#include <sys/sockio.h>
#endif

#include "tcputil.h"
#include "tcpip.h"
#include "log.h"
#include "err.h"

extern LogFile dbglogfile;

Tcputil::Tcputil(void)
    : _service(0),
      _proto(0),
      _addrinfo(0)
{
    // Get the hostname of this machine
    char hostname[MAXHOSTNAMELEN];
    std::memset(hostname, 0, MAXHOSTNAMELEN);
    if (gethostname(hostname, MAXHOSTNAMELEN) == 0) {
        _hostname = hostname;
        dbglogfile << "The hostname for this machine is " << hostname << std::endl;
    } else {
        dbglogfile << "WARNING: Couldn't get the hostname for this machine!" << std::endl;
    }

    dbglogfile << "Has " << numberOfInterfaces() << " interfaces, using default one" << std::endl;

    // Get the IP numbers for this machine
    if (getaddrinfo(hostname, NULL, NULL, &_addrinfo) == 0) {
        char _address[INET6_ADDRSTRLEN];
        struct addrinfo *addr = _addrinfo;
        while (addr->ai_next != 0) {
            if (addr->ai_socktype == SOCK_DGRAM) {
                std::memset(_address, 0, INET6_ADDRSTRLEN);
                _ipaddr = inet_ntop(AF_INET,
                                    &((struct sockaddr_in *)addr->ai_addr)->sin_addr,
                                    _address, INET6_ADDRSTRLEN);
                dbglogfile << "The IP number for this machine is " << _ipaddr << std::endl;
            }
            addr = addr->ai_next;
        }
    } else {
        dbglogfile << "WARNING: Couldn't get the host entry for this machine!" << std::endl;
    }
    
    _service = getservbyport(DEFAULTPORT, "tcp");
    if (_service) {
        dbglogfile <<  "Found service file entry for " << _service->s_name << std::endl;
        _proto = getprotobyname(_service->s_proto);
        if (_proto) {
            dbglogfile << "The proto number for " << _proto->p_name
                       << " is " << _proto->p_proto << std::endl;
        } else {
            dbglogfile << "WARNING: Couldn't get the host entry for this machine!" << std::endl;
        }
    } else {
        dbglogfile << "Services file entry for port " << DEFAULTPORT << " was not found!" << std::endl;
    }

}

Tcputil::~Tcputil(void)
{
    freeaddrinfo(_addrinfo);
}

struct servent *
Tcputil::lookupService(const std::string &name, const std::string &protocol)
{
    // Get the service entry from  /etc/services for this 
    _service = getservbyname(name.c_str(), protocol.c_str());

    if (_service) {
        dbglogfile <<  "Found service file entry for " << name << std::endl;
    } else {
        dbglogfile << "Services file entry " << name << " was not found!" << std::endl;
    }

    return _service;
}

// Description: Get the number of ethernet interfaces on this machine. Some
//              operating systems, like Solaris, support a ioctl()
//              specifically for discovering the number of interfaces,
//              so it exists, use that instead of SIOCGIFCONF.
int
Tcputil::numberOfInterfaces(void)
{
    int fd, count = 0;
#ifdef SIOCGLIFNUM
    struct lifnum ln;
#else
    char   buf[150], *cp, *cplim;
    struct ifconf ifc;
    struct ifreq *ifr;
#endif
    if (0 > (fd = socket(AF_INET, SOCK_DGRAM,0))) {
        dbglogfile << "WARNING: Couldn't get file descriptor for AF_INET socket!" << std::endl;
        return -1;
    }
#ifdef SIOCGLIFNUM
    // use AF_INET for IPv4 only or AF_INET6 for IPv6 only
    // note: if using AF_UNSPEC, some interface names may appear twice,
    //       once for IPv4 and once for IPv6
    ln.lifn_family = AF_UNSPEC;
    ln.lifn_flags = ln.lifn_count=0;


    if(ioctl(fd,SIOCGLIFNUM,&ln) == -1) {
        dbglogfile << "Couldn't get ethernet interface data!: %s\n"
                   << strerror(errno) << std::endl;
        return -1;
    }

    dbglogfile << "There are " <<  << ln.lifn_count " ethernet interfaces." << std::endl;

    return ln.lifn_count;
#else
    ifc.ifc_len = sizeof(buf);
    ifc.ifc_req = (struct ifreq *)buf;
    
    if(ioctl(fd, SIOCGIFCONF, &ifc) == -1) {
        dbglogfile << "Couldn't get ethernet interface data!: %s"
                   << strerror(errno) << std::endl;
        return -1;
    }
    
    ifr = ifc.ifc_req;
    cplim = buf + ifc.ifc_len;
    for (cp = buf; cp < cplim; cp += sizeof(ifr->ifr_name) + sizeof(ifr->ifr_addr)) {
        ifr = (struct ifreq *) cp;
#ifdef NET_DEBUG
        dbglogfile << "interface name is: " << ifr->ifr_name << std::endl;
#endif
        count++;
    }
#endif

    return count;
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
