// 
// Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
//               2014, 2015, 2016, 2017, 2018, 2019
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <sys/types.h>
#include <sys/stat.h>

#include <unistd.h>
#include <cstring>
#include <vector>
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlstring.h>

#include "xml.h"
#include "log.h"

// XMLNode methods. An XMLNode holds all the info for an XML node,
// including it's children and attributes.
// XMLNode::XMLNode()
// {
//     // DEBUGLOG_REPORT_FUNCTION;
// }

// XMLNode::~XMLNode()
// {
//     // DEBUGLOG_REPORT_FUNCTION;
//     unsigned int i;
// }

// Convert a raw XML node to a C++ representation
XMLNode *
XML::extractNode(xmlNodePtr node)
{
//    DEBUGLOG_REPORT_FUNCTION;
    xmlAttrPtr attr;
    xmlNodePtr childnode;
    xmlChar *ptr = NULL;
    XMLNode *child;
    int len;

    // BOOST_LOG_SEV(lg, severity_level::debug) << "extracting node " << node->name;
    XMLNode *xml = new XMLNode;
    std::string name;
    std::string value;

    // See if we have any Attributes (properties)
    if (attr = node->properties) {
        // extract all the attributes for this node
        while (attr != NULL) {
            name = reinterpret_cast<const char *>(attr->name);
            value = reinterpret_cast<const char *>(attr->children->content);
            xml->attribAdd(name, value);
            attr = attr->next;
#if 0
            BOOST_LOG_SEV(lg, severity_level::debug)
                << "FIXME: attribute " << node->name
                << " has property " << name
                << " value is " << value;
#endif
        }
    }

    if (node->name != 0) {
        name = reinterpret_cast<const char *>(node->name);
        xml->nameSet(name);
    }
    if (node->children) {
        // Sometimes the content is at the end of a line, so remove the
        // carriage return and trailing garbage.
        if (node->children->content != 0) {
            value = reinterpret_cast<char *>(node->children->content);
            xml->valueSet(value.substr(0, value.find('\n')));
        }
        
        ptr = xmlNodeGetContent(node->children);        
        if (ptr != NULL) {
            //value = reinterpret_cast<const char *>(node->children->content);
            value = reinterpret_cast<const char *>(ptr);
#if 0
            BOOST_LOG_SEV(lg, severity_level::debug)
                << "\tChild node: " << name
                << " has contents " << value;
#endif
            xml->valueSet(value.substr(0, value.find('\n')));
            xmlFree(ptr);
        }
    }

    // See if we have any data (content)
    childnode = node->children;

    while (childnode != NULL) {
        if (childnode->type == XML_ELEMENT_NODE) {
#if 0
            BOOST_LOG_SEV(lg, severity_level::debug)
                << "\tfound node " << (const char *)childnode->name;
#endif
            XMLNode *child = extractNode(childnode);
            //if (child->_value.get_type() != as_value::UNDEFINED) {
#if 0
            BOOST_LOG_SEV(lg, severity_level::debug)
                << "\tPushing child Node " << child->nameGet()
                << " value " << child->valueGet()
                <<  " on element " <<  xml->nameGet();
#endif
            xml->childAdd(child);
        }
        childnode = childnode->next;
    }

    return xml;
}

// This reads in an XML file from disk and parses into into a memory resident
// tree which can be walked through later.
bool
XML::parseMem(const std::string &xml_in)
{
    //DEBUGLOG_REPORT_FUNCTION;
    bool          ret = true;

    BOOST_LOG_SEV(lg, severity_level::debug)
        << "Parse XML from memory: \n\t" << xml_in.c_str();

    if (xml_in.size() == 0) {
        BOOST_LOG_SEV(lg, severity_level::error) << "XML data is empty!";
        return false;
    }

    xmlInitParser();
  
    _doc = xmlParseMemory(xml_in.c_str(), xml_in.size());
    if (_doc == 0) {
        BOOST_LOG_SEV(lg, severity_level::error) << "Can't parse XML data!";
        return false;
    }
    _nodes = extractNode(xmlDocGetRootElement(_doc));
    xmlCleanupParser();
    xmlFreeDoc(_doc);
    xmlMemoryDump();

    return ret;  
}

//     XML_READER_TYPE_NONE = 0
//     XML_READER_TYPE_ELEMENT = 1,
//     XML_READER_TYPE_ATTRIBUTE = 2,
//     XML_READER_TYPE_TEXT = 3,
//     XML_READER_TYPE_COMMENT = 8,
//     XML_READER_TYPE_SIGNIFICANT_WHITESPACE = 14,
//     XML_READER_TYPE_END_ELEMENT = 15,
//
// processNode:
// 2 1 IP 0
// processNode:
// 3 3 #text 0 192.168.2.50
// processNode:
// 2 15 IP 0
// processNode:
// 2 14 #text 0
const char *tabs[] = {
    "",
    "\t",
    "\t\t",
    "\t\t\t",
    "\t\t\t",
    "\t\t\t\t",
};

// This reads in an XML file from disk and parses into into a memory resident
// tree which can be walked through later.
bool
XML::parseFile(const std::string &filespec)
{
    DEBUGLOG_REPORT_FUNCTION;
    BOOST_LOG_SEV(lg, severity_level::debug) << "Load disk XML file: " << filespec;
  
    //BOOST_LOG(lg) << %s: mem is %d\n", __FUNCTION__, mem);

    xmlInitParser();
    _doc = xmlParseFile(filespec.c_str());
    if (_doc == 0) {
        BOOST_LOG_SEV(lg, severity_level::error) << "ERROR: Can't load XML file: "
                                                 << filespec;
        return false;
    }
    //_nodes = extractNode(xmlDocGetRootElement(_doc));
    _nodes = extractNode(xmlDocGetRootElement(_doc));
    xmlCleanupParser();
    xmlFreeDoc(_doc);
    xmlMemoryDump();

    return true;
}

void
XMLNode::operator = (XMLNode &node)
{
    _name = node.nameGet();
}

int
memadjust(int x)
{
    // DEBUGLOG_REPORT_FUNCTION;
    return (x + (4 - x % 4));
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
