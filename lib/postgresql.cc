// 
// Copyright (C) 2018
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <cstring>
#include <iostream>
#include <iomanip> 
#include <vector>
#include <cstdio>
#include <sstream>

#include "database.h"
#include "log.h"

#ifdef HAVE_LIBPQ
# include <libpq-fe.h>
#else
# warning "You need to install Postgresql for data base support"
#endif

const int LINELEN = 80;
const int QUERYLEN = 10000;

Database::Database()
    : _dbtype(NODB), _dbport(0)
{

    // These values may be replaced on the command line. These are the
    // default behaviour.
    _tblname  = DBTABLE;
    _dbname   = DBNAME;
    _dbuser   = DBUSER;
    _dbpasswd = DBPASS;
    _dbhost   = DBHOST;
}

Database::~Database()
{
    //closeDB();
}

// Accessors
void
Database::dbUserSet(std::string user)
{
    _dbuser = user;
}

void
Database::dbPasswdSet(std::string passwd)
{
    _dbpasswd = passwd;
}

void
Database::dbNameSet(std::string name)
{
    _dbname = name;
}

void
Database::dbHostSet(std::string host)
{
    _dbhost = host;
}

// methods that actually do something
bool
Database::openDB (void)
{
    DEBUGLOG_REPORT_FUNCTION;

    unsigned long flag = 0;

    BOOST_LOG(lg) <<"Connecting to Postgresql database "  << _dbname.c_str()
               << " on " << _dbhost.c_str()
               << " as user " << _dbuser.c_str();

    _connection = PQconnectdb("dbname = powerguru");
     /* Check to see that the backend connection was successfully made */
    if (PQstatus(_connection) != CONNECTION_OK)
    {
        BOOST_LOG(lg) << "ERROR: Connection to database failed";
        //exit_nicely(_connection);
    }

    return true;
}


bool
Database::closeDB (void)
{
    DEBUGLOG_REPORT_FUNCTION;
    //exit_nicely(_connection);
    
    return true;
}

bool
Database::queryInsert(const std::string &query)
{
    //DEBUGLOG_REPORT_FUNCTION;

    int retries, result;
    std::string str = "INSERT INTO onewire VALUES(";
    str += query + ");";

    BOOST_LOG(lg) << "Query is: " << query;
    
    if (PQexec(_connection, str.c_str()) == nullptr) {
        std::cerr << "Lost connection to the database server, shutting down...";
        std::cerr << PQerrorMessage(_connection) << std::endl;
    }
    
    return false;
}

  
void *
Database::queryResults(const char *query)
{
    DEBUGLOG_REPORT_FUNCTION;

    //MYSQL_RES	*result;
    //MYSQL_ROW	row;
    int         nrows;
    unsigned int i, res;

    BOOST_LOG(lg) << "Query is: " << query;

    // FIXME: return something intelligent here
    return (void *)0;
}

#if 0
bool
Database::queryInsert(vector<meter_data_t *> data)
{
    DEBUGLOG_REPORT_FUNCTION;

    struct tm      *ttm;
    struct timeval tp;
    unsigned int   i;
    //char           query[QUERYLEN];
    //char           *ptr;
    ostringstream  query;

    if (data.size() == 0) {
        BOOST_LOG(lg) << "No data to insert.";
        return false;
    }
  
    gettimeofday(&tp, 0);
    ttm = localtime (&tp.tv_sec);
    ttm->tm_year+= 1900;          // years since 1900
    ttm->tm_mon+=1;               // months since January

    query << "INSERT INTO inverter () VALUES ";

    for (i=0; i< data.size(); i++) {
        queryInsert(data[i]);
    }
  
    return true;  
}
#endif

#if 0
bool
Database::queryInsert(meter_data_t *data)
{
    DEBUGLOG_REPORT_FUNCTION;

    struct tm             *ttm;
    struct timeval        tp;
    //char                  query[QUERYLEN];
    char                  *type = "MX";
    std::ostringstream    query;

    query.str("");
    //  memset (query, 0, QUERYLEN);
  
    // EtaMsg em;
    // em.dump(*data);
  
    gettimeofday(&tp, 0);
    ttm = localtime (&tp.tv_sec);
    ttm->tm_year+= 1900;          // years since 1900
    ttm->tm_mon+=1;               // months since January

    string str = query.str().c_str();
  
    // Execute the query
    queryInsert(str.c_str());
  
    return true;
}
#endif

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
