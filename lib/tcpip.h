// 
//   Copyright (C) 2005 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//
#ifndef __TCPIP_H__
#define __TCPIP_H__

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
//#include <netdb.h>
#include <string>
#include <vector>
#include <libxml/encoding.h>
#include <libxml/xmlwriter.h>
#include <libxml/debugXML.h>


#include "log.h"
#include "err.h"
#include "tcputil.h"

class Tcpip : public Tcputil
{
 public:
  Tcpip();
  ~Tcpip();

  // Create a new server. Ate creating it, then you have to wait for an
  // incoming connection.
  retcode_t createNetServer(void);
  retcode_t createNetServer(short port);
  retcode_t createNetServer(std::string &service);
  retcode_t createNetServer(std::string &service, std::string &protocol);
  retcode_t createNetServer(short port, std::string &protocol);

  // Accept a client connection for the current server.
  retcode_t newNetConnection(void);
  retcode_t newNetConnection(bool block);
  
  // Create a client connection to a tcp/ip server
  retcode_t createNetClient(void);
  retcode_t createNetClient(short port);
  retcode_t createNetClient(std::string &hostname);
  retcode_t createNetClient(std::string &hostname, short port);
  retcode_t createNetClient(std::string &hostname, std::string &service);
  retcode_t createNetClient(std::string &hostname, std::string &service, std::string &protocol);
  retcode_t createNetClient(std::string &hostname, short port, std::string &protocol);

  // If there is any data, process it
  retcode_t anydata(std::vector<const xmlChar *> &msgs);
  retcode_t anydata(int sockfd, std::vector<const xmlChar *> &msgs);

  // Read from the socket
  int readNet(char *buffer, int nbytes);
  int readNet(char *buffer, int nbytes, int timeout);
  int readNet(int fd, char *buffer, int nbytes);
  int readNet(int fd, char *buffer, int nbytes, int timeout);
  
  // Write to the socket  
  int writeNet(std::string buffer);
  int writeNet(char const *buffer);
  int writeNet(char const *buffer, int nbytes);
  int writeNet(int fd, char const *buffer);
  int writeNet(int fd, char const *buffer, int nbytes);
  int writeNet(int fd, char const *buffer, int nbytes, int timeout);
                                                                           
  // Close the connection
  retcode_t closeNet();
  retcode_t closeNet(int fd);
  
  // Change the debug flag
  void toggleDebug(bool val);  
  
  // Authenticate the socket connection
  retcode_t authNetClient(void);
  retcode_t authNetServer(void);

  // Extract some info from the other end of the connection.
  const std::string remoteIP(void);
  const std::string remoteIP(struct in_addr addr);
  const std::string remoteName(void);
  const std::string remoteName(struct in_addr addr);

  Tcpip &operator = (Tcpip &tcp);  
private:
  static int               _sockfd;
  static int               _sockIOfd;
  in_addr_t                _ipaddr;
  std::string              _hostname;
  struct sockaddr_in	   _client;
  const char              *_proto;
  short                    _port;
  bool                     _debug;
};

// EOF __TCPIP_H__ */
#endif
