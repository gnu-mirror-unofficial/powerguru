// 
// Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

#ifndef __TCPIP_H__
#define __TCPIP_H__

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <boost/asio/io_service.hpp>
#include <boost/asio/write.hpp>
#include <boost/asio/buffer.hpp>
#include <boost/asio/ip/tcp.hpp>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <cstring>
#include <vector>
#include <sys/ioctl.h>

#include "tcputil.h"

extern const std::string DEFAULTPROTO;
extern const short DEFAULTPORT;

class Tcpip : public Tcputil
{
public:
    Tcpip(void) {};
    ~Tcpip(void) {};

    // Create a new server. After creating it, then you have to wait for an
    // incoming connection.
    retcode_t createNetServer(void) {
        return createNetServer(DEFAULTPORT);
    };
    retcode_t createNetServer(short port) {
        return createNetServer(port, DEFAULTPROTO);
    };
    retcode_t createNetServer(const std::string &service) {
        return createNetServer(service, DEFAULTPROTO);
    };
    retcode_t createNetServer(const std::string &service, const std::string &protocol);
    retcode_t createNetServer(short port, const std::string &protocol);

    // Accept a client connection for the current server.
    retcode_t newNetConnection(void);
    retcode_t newNetConnection(bool block);

    // Create a client connection to a tcp/ip server
    retcode_t createNetClient(void) {
        return createNetClient("localhost", DEFAULTPORT, DEFAULTPROTO);
    };
    retcode_t createNetClient(short port) {
        return createNetClient("localhost", port, DEFAULTPROTO);
    };
    retcode_t createNetClient(const std::string &hostname) {
        return createNetClient(hostname, DEFAULTPORT, DEFAULTPROTO);
    };
    retcode_t createNetClient(const std::string &hostname, short port) {
        return createNetClient(hostname, port, DEFAULTPROTO);
    };
    retcode_t createNetClient(const std::string &hostname, const std::string &service) {
        return createNetClient(hostname, service, DEFAULTPROTO);
    };
    
    retcode_t createNetClient(const std::string &hostname, const std::string &service,
                              const std::string &protocol);
    retcode_t createNetClient(const std::string &hostname, short port,
                              const std::string &protocol);

    // If there is any data, process it
    retcode_t anydata(std::vector<const unsigned char *> &msgs);
    retcode_t anydata(int sockfd, std::vector<const unsigned char *> &msgs);

    // Read from the socket
    std::vector<unsigned char> &readNet(std::vector<unsigned char> &buf);
  
    // Write to the socket  
    int writeNet(const std::vector<unsigned char> &buffer);
    int writeNet(const std::string &buffer);

    // Close the connection
    retcode_t closeNet();
    retcode_t closeConnection();

    // Authenticate the socket connection
    retcode_t authNetClient(void);
    retcode_t authNetServer(void);

    // Extract some info from the other end of the connection.
    const std::string &remoteIP(void);
    const std::string &remoteIP(struct in_addr addr);
    const std::string &remoteName(void);
    const std::string &remoteName(struct in_addr addr);
    const std::string &hostname(void) { return _hostname; };

    Tcpip &operator = (Tcpip &tcp);

    void checkConsole(void) { _console = true; };
    // Get the number of bytes in the incoming data TCP/IP packet.
    // This is used to have more efficient memory allocation.
    int checkBytes() {
        int bytes = 0;
        ioctl(_sockfd, FIONREAD, &bytes);
        return bytes;
    }
  
protected:
    int                 _sockfd;
    std::vector<int>    _connections;
    int                 _sockIOfd;
    //in_addr_t         _ipaddr;
    std::string         _hostname;
    struct sockaddr_in	_client;
    //std::string       _proto;
    short               _port;
    bool                _console;
};

/////////////////////////////////////////////
using namespace boost::asio;
using namespace boost::asio::ip;

extern void read_handler(const boost::system::error_code &ec,
                  std::size_t bytes_transferred);
extern void connect_handler(const boost::system::error_code &ec);
extern void resolve_handler(const boost::system::error_code &ec,
                            boost::asio::ip::tcp::resolver::iterator it);
extern void write_handler(const boost::system::error_code &ec,
                   std::size_t bytes_transferred);
void accept_handler(const boost::system::error_code &ec);
    
// EOF __TCPIP_H__ */
#endif

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
