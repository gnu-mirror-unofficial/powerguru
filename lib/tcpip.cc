// 
// Copyright (C) 2005, 2006 - 2018
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <errno.h>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <vector>
#include <iostream>
#include <sys/param.h>
#include <fcntl.h>

#include "tcpip.h"
#include "tcputil.h"
#include "log.h"

//static const char *SERVICENAME = "powerguru";
const std::string DEFAULTPROTO = "tcp"; // tcp or udp
const short DEFAULTPORT  = 7654;

static const int INBUF          = 2048;
static const int DEFAULTTIMEOUT = 5;
const int BLOCKING_TIMEOUT      = -1;

extern LogFile dbglogfile;

#ifndef INADDR_NONE
#define INADDR_NONE  0xffffffff
#endif

Tcpip::Tcpip(void)

{
    DEBUGLOG_REPORT_FUNCTION;
}

Tcpip::~Tcpip(void)
{
    DEBUGLOG_REPORT_FUNCTION;

    std::vector<int>::iterator it;
//    for (it = _connection.begin(); it != _connections.end(); it++) {
//        closeConnection(it);
//    }

    //next.join();
    closeNet();
}

// Description: Create a tcp/ip network server. This creates a server
//              that listens for incoming socket connections. This
//              support IP aliasing on the host, and will sequntially
//              look for IP address to bind this port to.
retcode_t
Tcpip::createNetServer(const std::string &service, const std::string &proto)
{
    DEBUGLOG_REPORT_FUNCTION;

    dbglogfile << "Port number is " << _service->s_port
               << ", byte swapped is " << htons(_service->s_port) << std::endl;

    // Store the port number
    _port = _service->s_port;
    //_proto = serv->s_proto;
  
    return createNetServer(_service->s_port, proto);
}

retcode_t
Tcpip::createNetServer(short port, const std::string &protocol)
{
    DEBUGLOG_REPORT_FUNCTION;
  
    struct protoent *ppe = 0;
    struct sockaddr_in sock_in;
    int             on, type;
    const struct hostent  *host;
    struct in_addr  *thisaddr = 0, newaddr;
    in_addr_t       nodeaddr, netaddr;
  
    struct addrinfo *addr = getAddrInfo("", port);
    if (addr) {
        // Get a file descriptor for this socket connection
        _sockIOfd = ::socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
        if (_sockIOfd < 0) {
            std::cerr << "ERROR: unable to create socket: " << strerror(errno) << std::endl;
            return ERROR;
        }
    } else {
        std::cerr << "ERROR: unable to get address! " << gai_strerror(errno) << std::endl;
        return ERROR;
    }
    
    if (bind(_sockIOfd, addr->ai_addr, addr->ai_addrlen) == -1) {
        dbglogfile << "WARNING: unable to bind to"
                   << inet_ntoa(sock_in.sin_addr)
                   << " port!" << strerror(errno) << std::endl;
        if (errno == EADDRINUSE) {
            std::cerr << "ERROR: There is another process already bound to this port!"
                      << std::endl;
            return ERROR;
        }
    }
    
    dbglogfile << "Server bound to port: " << port
               << " on IP " << inet_ntoa(((struct sockaddr_in *)addr->ai_addr)->sin_addr)
                   << " using fd #" << _sockIOfd << std::endl;
    
    if (listen(_sockIOfd, 5) < 0) {
        dbglogfile << "ERROR: unable to listen on port: "
                   << port << ": " <<  strerror(errno) << std::endl; 
        return ERROR;
    }
    
    dbglogfile << "Listening for net traffic on fd #" << _sockIOfd << std::endl;

    return SUCCESS;
}

// Description: Accept a new network connection for the port we have
//              created a server for.
// The default is to block.
retcode_t
Tcpip::newNetConnection(void)
{
    DEBUGLOG_REPORT_FUNCTION;
    return newNetConnection(true);
}

retcode_t
Tcpip::newNetConnection(bool block)
{
    DEBUGLOG_REPORT_FUNCTION;
    struct sockaddr fsin;
    int		    ret;
    socklen_t	    alen = 0;
    struct timeval  tval;
    fd_set          fdset;
    int             retries = 3;

    dbglogfile << "Trying to accept net traffic on fd #" << _sockIOfd << std::endl;
  
    if (_sockIOfd <= 2) {
        return ERROR;
    }

#if 0
    while (retries--) {
        // We use select to wait for the read file descriptor to be
        // active, which means there is a client waiting to connect.
        FD_ZERO(&fdset);
        FD_SET(_sockIOfd, &fdset);
    
        // Reset the timeout value, since select modifies it on return. To
        // block, set the timeout to zero.
        tval.tv_sec = 10;
        tval.tv_usec = 0;
    
        if (block) {
            ret = select(_sockIOfd+1, &fdset, NULL, NULL, NULL);
        } else {
            ret = ::select(_sockIOfd+1, &fdset, NULL, NULL, &tval);
        }
    
        if (FD_ISSET(0, &fdset)) {
            dbglogfile << "There is data at the console for stdin!" << std::endl;
            return SUCCESS;
        }

        // If interupted by a system call, try again
        if (ret == -1 && errno == EINTR) {
            dbglogfile <<
                "The accept() socket for fd #%d was interupted by a system call!"
                       << _sockIOfd << std::endl;
        }
    
        if (ret == -1) {
            dbglogfile << "ERROR: The accept() socket for fd " << _sockIOfd
                       << " never was available for writing!" << std::endl;
            return ERROR;
        }
    
        if (ret == 0) {
            dbglogfile <<
                "ERROR: The accept() socket for fd #%d timed out waiting to write!"
                       << _sockIOfd << std::endl;
        }
        if (ret >= 1) {
            dbglogfile << "The accept() socket got something!" << std::endl;
        }
    }
#endif

    ::memset(&fsin, 0,  sizeof(struct sockaddr_in));
    //::fcntl(_sockIOfd, F_SETFL, O_NONBLOCK); // Don't let accept() block
    _sockfd = ::accept(_sockIOfd, &fsin, &alen);
  
    if (_sockfd < 0) {
        dbglogfile << "ERROR: unable to accept : " << strerror(errno) << std::endl;
        return ERROR;
    } else {
        dbglogfile << "Accepting tcp/ip connection on fd #" << _sockfd << std::endl;
    }

    std::memcpy(&_client, &fsin, sizeof(struct sockaddr));
  
    _connections.push_back(_sockfd);
    return SUCCESS;
}

retcode_t
Tcpip::createNetClient(const std::string &hostname,
                       const std::string &srvname,
                       const std::string &protocol)
{
    DEBUGLOG_REPORT_FUNCTION;
    //return createNetClient(hostname, srvname, "tcp");
}

retcode_t
Tcpip::createNetClient(const std::string &hostname, short port,
                       const std::string &protocol)
{
    DEBUGLOG_REPORT_FUNCTION;
    fd_set              fdset;
    struct timeval      tval;
    int                 ret;
    int                 retries;
    std::string         portstr = std::to_string(port);
    addrinfo            req;

    // Get the address data for this host
    struct addrinfo *addr = getAddrInfo(hostname, port);
    if (addr) {
        _sockfd = ::socket(addr->ai_family, addr->ai_socktype, _proto->p_proto);
        if (_sockfd < 0) {
            dbglogfile << "WARNING: unable to create socket: "
                       << ::strerror(errno) << std::endl;
            return ERROR;
        }

        dbglogfile << "Trying to connect to: " << hostname << ":" << port << std::endl;
        if (::connect(_sockfd, addr->ai_addr, addr->ai_addrlen) < 0) {
            dbglogfile << "ERROR: Couldn't connect to: " << hostname << " "
                       << strerror(errno) << std::endl;
            retries = 1;
            while (retries-- > 0) {
                // We use select to wait for the read file descriptor to be
                // active, which means there is a client waiting to connect.
                FD_ZERO(&fdset);
                FD_SET(_sockfd, &fdset);
                // Reset the timeout value, since select modifies it on return. To
                // block, set the timeout to zero.
                tval.tv_sec = 5;
                tval.tv_usec = 0;
                ret = ::select(_sockfd+1, &fdset, NULL, NULL, &tval);
                // If interupted by a system call, try again
                if (ret == -1 && errno == EINTR) {
                    dbglogfile <<
                        "The connect() socket for fd #%d was interupted by a system call!"
                               << _sockfd << std::endl;
                }
                if (ret == -1) {
                    dbglogfile <<
                        "The connect() socket for fd #%d never was available for writing!"
                               << _sockfd << std::endl;
                    shutdown(_sockfd, SHUT_RDWR);
                    return ERROR;
                }
                if (ret == 0) {
                    dbglogfile <<
                        "WARNING: The connect() socket for fd #%d timed out waiting to write!"
                               << _sockfd << std::endl;
                }
            }
            ret = ::connect(_sockfd, addr->ai_addr, addr->ai_addrlen);
            if (ret <= 0) {
                dbglogfile << "unable to connect to "
                           << hostname
                           << ", port " << port
                           << ": " << strerror(errno) << std::endl;
                close(_sockfd);
                return ERROR;
            }
            if (ret <= 0) {
                dbglogfile << "unable to connect to "
                           << hostname
                           << ", port " << port
                           << ": " << strerror(errno) << std::endl;
                close(_sockfd);
                return ERROR;
            }
        }
    }

    _hostname = hostname;
    char ascip[INET_ADDRSTRLEN];
    std::memset(ascip, 0, INET_ADDRSTRLEN);
    //inet_ntop(AF_INET, &_ipaddr, ascip, INET_ADDRSTRLEN);
    dbglogfile << "Client connected to service at port " << port
               << " at IP " << ascip
               << " using fd #" << _sockfd << std::endl;
  
    // For a client, the IO file descriptor is the same as the default one
    _sockIOfd = _sockfd;

    return SUCCESS;
}

// Description: Close an open socket connection.
retcode_t
Tcpip::closeConnection(void)
{
    DEBUGLOG_REPORT_FUNCTION;

    if (_sockfd > 0) {
        close(_sockfd);
        _sockfd = 0;
        return SUCCESS;
    }
  
    return ERROR;
}
retcode_t
Tcpip::closeNet(void)
{
    DEBUGLOG_REPORT_FUNCTION;
  
    int retries = 0;
  
    // If we can't close the socket, other processes must be
    // locked on it, so we wait a second, and try again. After a
    // few tries, we give up, cause there must be something
    // wrong.

    if (_sockfd <= 0) {
        return SUCCESS;
    }
  
    while (retries < 3) {
        if (_sockfd) {
            // Shutdown the socket connection
#if 0
            if (shutdown(_sockfd, SHUT_RDWR) < 0) {
                if (errno != ENOTCONN) {
                    dbglogfile << "WARNING: Unable to shutdown socket for fd #"
                               << _sockfd << strerror(errno) << std::endl;
                } else {
                    dbglogfile << "The socket using fd #" << _sockfd
                               << " has been shut down successfully." << std::endl;
                    return SUCCESS;
                }
            }
#endif 
            if (close(_sockfd) < 0) {
                dbglogfile <<
                    "WARNING: Unable to close the socket for fd "
                           <<	_sockfd << strerror(errno) << std::endl;
                sleep(1);
                retries++;
            } else {
                // dbglogfile << "Closed the socket for "
                //            << (_service->s_name
                //            << " on fd " << _sockfd << std::endl;
                return SUCCESS;
            }
        }
    }
  
    return ERROR;
}

// Return true if there is data in the socket, otherwise return false.
retcode_t
Tcpip::anydata(std::vector<const unsigned char *> &msgs)
{
    DEBUGLOG_REPORT_FUNCTION;
    //printf("%s: \n", __FUNCTION__);
    return anydata(_sockfd, msgs);
}

// This waits for data on the socket, and on stdin. This way we can sit
// here in a kernel sleep instead of polling all devices.
retcode_t
Tcpip::anydata(int fd, std::vector<const unsigned char *> &msgs)
{
    DEBUGLOG_REPORT_FUNCTION;
    fd_set                fdset;
    struct timeval        tval;
    int                   ret = 0;
    char                  buf[INBUF];
    char                  *packet;
    int                   retries = 10;
    char                  *ptr, *eom;
    int                   cr, index = 0;
    static char           *leftover = 0;
    int                   adjusted_size;

    if (fd <= 0) {
        return ERROR;
    }
  
    //fcntl(_sockfd, F_SETFL, O_NONBLOCK);

    //msgs = (char **)realloc(msgs, sizeof(char *));
    while (retries-- > 0) {
        FD_ZERO(&fdset);
        // also return on any input from stdin
        FD_SET(fd, &fdset);
    
        tval.tv_sec = 10;
        tval.tv_usec = 10;
    
        ret = ::select(fd+1, &fdset, NULL, NULL, &tval);

        // If interupted by a system call, try again
        if (ret == -1 && (errno == EINTR || errno == EAGAIN)) {
            dbglogfile << "The socket for fd #%d was interupted by a system call!"
                       << fd << std::endl;
            continue;
        }
        if (ret == 0) {
            dbglogfile << "There is no data in the socket for fd #" << fd << std::endl;
            // msgs.clear();
            return SUCCESS;
        }
        if (ret == -1) {
            dbglogfile << "The socket for fd #%d never was available!" << fd << std::endl;
            return ERROR;
        }
        if (ret > 0) {
            dbglogfile << "There is data in the socket for fd #" << fd << std::endl;
        }

        memset(buf, 0, INBUF);
        if (FD_ISSET(_sockfd, &fdset)) {
            ret = ::read(_sockfd, buf, INBUF-2);
        } else {
            return ERROR;
        }
    
        if (ret == 0) {
            return ERROR;
        }
    
        if (ret == -1) {
            switch (errno) {
              case EAGAIN:
                  continue;
                  break;
              default:
                  break;
            };
            return ERROR;
        }
        cr = strlen(buf);
        //dbglogfile << "read " << ret << " bytes, first msg terminates at " << cr << std::endl;
        //dbglogfile << "read " << buf << std::endl;
        ptr = buf;
        // If we get a single XML message, do less work
        if (ret == cr + 1) {
            // adjusted_size = memadjust(ret + 1); FIXME:
            packet = new char[adjusted_size];
            //printf("Packet size is %d at %p\n", ret + 1, packet);
            memset(packet, 0, adjusted_size);
            strcpy(packet, ptr);
            eom = strrchr(packet, '\n'); // drop the CR off the end if there is one
            if (eom) {
                *eom = 0;
            }
            //    msgs[index] = (const unsigned char *)packet;
            msgs.push_back((const unsigned char *)packet);
            //      msgs[index+1] = 0;
            //printf("%d: Pushing Packet of size %d at %p\n", __LINE__, strlen(packet), packet);
            //processing(false);
      
            return SUCCESS;
        }

        // If we get multiple messages in a single transmission, break the buffer
        // into separate messages.
        while ((strchr(ptr, '\0') > 0) && (ptr > 0)) {
            if (leftover) {
                //processing(false);
                printf("%s: The remainder is: \"%s\"\n", __FUNCTION__, leftover);
                printf("%s: The rest of the message is: \"%s\"\n", __FUNCTION__, ptr);
                // adjusted_size = memadjust(cr + strlen(leftover) + 1); FIXME:
                packet = new char[adjusted_size];
                memset(packet, 0, adjusted_size);
                strcpy(packet, leftover);
                strcat(packet, ptr);
                eom = strrchr(packet, '\0'); // drop the CR off the end there is one
                if (eom) {
                    *eom = 0;
                }
                printf("%s: The whole message is: \"%s\"\n", __FUNCTION__, packet);
                ptr = strchr(ptr, '\0') + 2; // messages are delimited by a "\n\0"
                delete leftover;
                leftover = 0;
            } else {
                // adjusted_size = memadjust(cr + 1); FIXME:
                packet = new char[adjusted_size];
                memset(packet, 0, adjusted_size);
                strcpy(packet, ptr);
                ptr += cr + 1;
                //dbglogfile << "Packet is: " << packet << std::endl;
            } // end of if remainder
            if (*packet == '<') {
                eom = strrchr(packet, '\n'); // drop the CR off the end there is one
                if (eom) {
                    *eom = 0;
                }
                //printf("Allocating new packet at %p\n", packet);
                //data.push_back(packet);
                //        msgs[index++] = (const unsigned char *)packet;
                msgs.push_back((const unsigned char *)packet);
            } else {
                if (*packet == *ptr) {
                    // dbglogfile << "Read all XML messages in packet " << packet << std::endl;
                    break;
                } else { 
                    //dbglogfile << "WARNING: Throwing out partial packet " << std::endl;
                    dbglogfile << "WARNING: Throwing out partial packet " << packet << std::endl;
                    break;
                }
            }
      
            cr = strlen(ptr);
        } // end of while (cr)
    
        if (strlen(ptr) > 0) {
            leftover = new char[strlen(ptr) + 1];
            strcpy(leftover, ptr);
            //processing(true);
            printf("%s: Adding remainder: \"%s\"\n", __FUNCTION__, leftover);
        }
    
        //processing(false);
        if (msgs.size() == 0) {
            return ERROR;
            //      printf("Returning %d messages\n", msgs.size());
        }
        return SUCCESS;
    
    } // end of while (retires)

    return SUCCESS;
}

// This blocks waiting for data on the socket, so it's easy on the cpu. If
// There is data, it peeks at how many bytes there are in the socket, and
// allocates a buffer of the exact size.
std::vector<unsigned char> &
Tcpip::readNet(std::vector<unsigned char> &buf)
{
    //DEBUGLOG_REPORT_FUNCTION;
    fd_set              fdset;
    int                 ret = 0;
    struct timeval      tval;

    // Wait for the socket to be ready for reading
    if (_sockfd > 2) {
        FD_ZERO(&fdset);
        FD_SET(_sockfd, &fdset);
    } else {
        dbglogfile << "WARNING: Can't do anything with socket fd #"
                   << _sockfd << std::endl;
        buf.clear();
        buf.push_back(255);
        return buf;
    }
  
    tval.tv_sec = DEFAULTTIMEOUT;
    tval.tv_usec = 0;
    ret = select(_sockfd+1, &fdset, NULL, NULL, &tval);

    if (ret <= 0 && tval.tv_sec == 0) {
        buf.clear();
        return buf;
    }

    int nbytes = checkBytes();
    buf.clear();
    // This is a hack to preset the size of the data in the vector
    buf.resize(nbytes + 1);
    unsigned char *buffer = buf.data();

    // If interupted by a system call, try again
    if (ret == -1 && errno == EINTR) {
        dbglogfile <<
            "The socket for fd #" << _sockfd << " we interupted by a system call!"
                                  << std::endl;
        dbglogfile << "WARNING: error is " << strerror(errno) << std::endl;
    }
  
    if (ret == -1) {
        dbglogfile << "The socket for fd #" << _sockfd << " never was available for reading!"
                   << std::endl;
    }
  
#if 0                           // FIXME: too verbose
    if (ret == 0) {
        dbglogfile <<
            "The socket for fd #" << _sockfd << " timed out waiting to read!" << std::endl;
    }
#endif
    ret = read(_sockfd, buffer, nbytes);
#if 0
    if (ret != 0) {
        dbglogfile << "Read " << ret << " bytes from fd #" << _sockfd << std::endl;
        dbglogfile << "Buffer says " << buffer << std::endl;
        dbglogfile << "Read " << (int)buf.size() << " bytes from fd #" << _sockfd << std::endl;
        dbglogfile << "Buffer says " << buf.data() << std::endl;
    }
#endif

    return buf;
}

int
Tcpip::writeNet(const std::string &buffer) {
    const unsigned char *raw = reinterpret_cast<const unsigned char *>(buffer.c_str()); 
    std::vector<unsigned char> str(raw, raw + buffer.size());

     return writeNet(str);
}

int
Tcpip::writeNet(const std::vector<unsigned char> &buffer)
{
     DEBUGLOG_REPORT_FUNCTION;
    fd_set              fdset;
    int                 ret = 0;
    const unsigned char *bufptr;
    struct timeval      tval;
    int                 retries = 3;
  
    bufptr = buffer.data();
    int nbytes = buffer.size();

    dbglogfile << "Writing data to socket." << std::endl;

    while (retries-- > 1) {
        // Wait for the socket to be ready for writing
        if (_sockfd > 2) {
            FD_ZERO(&fdset);
            FD_SET(_sockfd, &fdset);
        } else {
            dbglogfile << "WARNING: Can't do anything with socket fd #!"
                       << _sockfd << std::endl;
            return -1;
        }
    
        // Reset the timeout value, since select modifies it on return
        tval.tv_sec = DEFAULTTIMEOUT;
        tval.tv_usec = 100;
        ret = select(_sockfd+1, NULL, &fdset, NULL, &tval);
    
        // If interupted by a system call, try again
        if (ret == -1 && errno == EINTR) {
            dbglogfile <<
                "The socket for fd #" << _sockfd << " we interupted by a system call!" << std::endl;
        }
    
        if (ret == -1) {
            dbglogfile << "The socket for fd #" << _sockfd
                       << " never was available for writing!" << std::endl;
            continue;
        }
    
        if (ret == 0) {
            dbglogfile << "The socket for fd #"
                       << _sockfd << " timed out waiting to write!" << std::endl;
            continue;
        }
        ret = write(_sockfd, bufptr, nbytes);
        // Add a LF/CR to flush the buffer.
        // write(fd, "\r\n", 2);
    
    
        if (ret == 0) {
            dbglogfile << "Couldn't write any bytes to fd #" << _sockfd << std::endl;
            return ret;
        }
    
        if (ret < 0) {
            dbglogfile << "Couldn't write " << nbytes << " bytes to fd #"
                       << _sockfd << std::endl;
            return ret;
        }
    
        if (ret > 0) {
            bufptr += ret;            
            if (ret != nbytes) {
                dbglogfile << "wrote " << ret << " bytes to fd #"
                           << _sockfd << " expected " <<  nbytes << std::endl;
                retries++;
            } else {
#if 0
                dbglogfile << "Wrote " << ret << " bytes to fd #" << _sockfd << std::endl;
#endif
                return ret;
            }
      
            if (ret == 0) {
                dbglogfile << "Wrote 0 bytes to fd #" << _sockfd << std::endl;
            }
        }
    }
  
    return ret;
}

Tcpip &
Tcpip::operator = (Tcpip &tcp) 
{
    _sockfd = _sockfd;
    _sockIOfd = _sockIOfd;
    //_ipaddr = _ipaddr;
    _hostname = _hostname;
    //memcpy(_client, tcp._client, sizeof(sockaddr_in);
    //_proto = strdup(_proto);
    _port = _port;
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
