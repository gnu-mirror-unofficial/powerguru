// 
// Copyright (C) 2005, 2006 - 2018
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <iostream>
#include <fstream>
#include <cstring>
#include <iterator>
#include <map>
#include <boost/system/error_code.hpp>
# include <sstream>
#ifdef HAVE_LIBXML
# include <libxml/encoding.h>
# include <libxml/xmlwriter.h>
# include <libxml/debugXML.h>
# include "xml.h"
#endif
#include "log.h"
#include "msgs.h"
#include "tcputil.h"
#include "tcpip.h"

Msgs::net_mode_e  Msgs::_net_mode;
std::map<const char *, Msgs::methodPtr_t> Msgs::_methods;
std::map<const char *, std::string> Msgs::_cache;

#define MY_ENCODING "ISO-8859-1"

Msgs::Msgs()
{
    // DEBUGLOG_REPORT_FUNCTION;
    Tcputil tu;
    tu.hostDataGet();
  
    _thisip = tu.hostIPNameGet();
    _thishost = tu.hostNameGet();

    _version = atof(VERSION);
}

Msgs::Msgs(const std::string &host, const std::string &ip) // : _net_mode(NONET)
{
    // DEBUGLOG_REPORT_FUNCTION;
    Tcputil tu;
    tu.hostDataGet();
  
    _thisip = tu.hostIPNameGet();
    _thishost = tu.hostNameGet();
  
    _remoteip = ip;
    _remotehost = host;

    _version = atof(VERSION);
}

Msgs::Msgs(Tcpip *tcpip)//  : _net_mode(NONET)
{
    // DEBUGLOG_REPORT_FUNCTION;
    Tcputil tu;
    tu.hostDataGet();
  
    _thisip = tu.hostIPNameGet();
    _thishost = tu.hostNameGet();
  
    //  _remoteip = ip;
    //  _remotehost = host;
  
    _version = atof(VERSION);
}

boost::system::error_code
Msgs::init(net_mode_e mode)
{
    DEBUGLOG_REPORT_FUNCTION;
    std::string hostname = "localhost";
    bool block = true;
  
    if (mode == CLIENT) {
        _net_mode = CLIENT;
        if (createNetClient(hostname)) {
            BOOST_LOG(lg) << "Connected to server at " << hostname.c_str() << std::endl;
            init();                     // initialize the table of pointers
            errc::make_error_code(errc::success);
        } else {
            BOOST_LOG(lg) << "ERROR: Couldn't create connection to server" << hostname.c_str()  << std::endl;
        }
    } else if (mode == DAEMON) {
        _net_mode = DAEMON;
        init(DAEMON, block);
        BOOST_LOG(lg) << "WARNING: ignoring hostname, starting as daemon" << std::endl;
    } else {
        BOOST_LOG(lg) << "ERROR: no mode specified! " << std::endl;
        _net_mode = NONET;
    }
    errc::make_error_code(errc::not_supported);  
}

// If a hostname is specifed, we force client mode.
boost::system::error_code
Msgs::init(net_mode_e mode, const std::string &hostname)
{
    DEBUGLOG_REPORT_FUNCTION;
    return init(hostname);
}

// By default, if just a hostname is supplied, we assume it's to establish
// a network connection to the specified host.
boost::system::error_code
Msgs::init(const std::string &hostname)
{
    DEBUGLOG_REPORT_FUNCTION;
  
    if (createNetClient(hostname)) {
        BOOST_LOG(lg) << "Connected to server at " << hostname << std::endl;
        init();                     // initialize the table of pointers
        _net_mode = CLIENT;
        writeNet(heloCreate(_version));
        errc::make_error_code(errc::success);
    } else {
        BOOST_LOG(lg) << "ERROR: Couldn't create connection to server" << hostname  << std::endl;
    }
    errc::make_error_code(errc::not_supported);
}

boost::system::error_code
Msgs::init(net_mode_e mode, bool block)
{
    DEBUGLOG_REPORT_FUNCTION;
    std::string hostname = "localhost";
    if (mode == CLIENT) {
        _net_mode = CLIENT;
        if (createNetClient(hostname)) {
            BOOST_LOG(lg) << "Connected to server at " << hostname.c_str() << std::endl;
            init();                     // initialize the table of pointers
            errc::make_error_code(errc::success);
        } else {
            BOOST_LOG(lg) << "ERROR: Couldn't create connection to server" << hostname.c_str()  << std::endl;
        }
    } else if (mode == DAEMON) {
        _net_mode = DAEMON;
        init(true);
        BOOST_LOG(lg) << "WARNING: ignoring hostname, starting as daemon" << std::endl;
    } else {
        BOOST_LOG(lg) << "ERROR: no mode specified! " << std::endl;
        _net_mode = NONET;
    }
    errc::make_error_code(errc::not_supported);
}
               
boost::system::error_code
Msgs::init(bool block)
{
    DEBUGLOG_REPORT_FUNCTION;
    _net_mode = DAEMON;
  
    if (createNetServer()) {
        BOOST_LOG(lg) << "New server started for remote client." << std::endl;
        init();                     // initialize the table of pointers
    } else {
        BOOST_LOG(lg) << "ERROR: Couldn't create a new server" << std::endl;
    }      
  
    if (newNetConnection(block)) {
        BOOST_LOG(lg) << "New connection started for remote client." << std::endl;
        _net_mode = DAEMON;
        writeNet(heloCreate(_version));
        errc::make_error_code(errc::success);
    } else {
        BOOST_LOG(lg) << "ERROR: Couldn't create a new connection!" << std::endl;
    }
    errc::make_error_code(errc::not_supported);
}

  
boost::system::error_code
Msgs::init(void)
{
    DEBUGLOG_REPORT_FUNCTION;

    // Top level node of the message
    _methods[ "powerguru"] =      &Msgs::powerguruProcess;
  
    // initialization message
    _methods[ "helo"] =           &Msgs::heloProcess;
    _methods[ "client"] =         &Msgs::clientProcess;
    _methods[ "server"] =         &Msgs::serverProcess;
  
    // Meter readings
    _methods[ "meters"] =         &Msgs::metersProcess;
    _methods[ "charge-mps"] =     &Msgs::chargeAmpsProcess;
    _methods[ "load-amps"] =      &Msgs::loadAmpsProcess;
    _methods[ "pv-amps"] =        &Msgs::pvAmpsProcess;
    _methods[ "pv-volts"] =       &Msgs::pvVoltsProcess;
    _methods[ "daily-kwh"] =      &Msgs::dailyKwhProcess;
    _methods[ "hertz"] =          &Msgs::hertzProcess;
    _methods[ "battery-volts"] =  &Msgs::batteryVoltsProcess;
    _methods[ "buy-amps"] =       &Msgs::buyAmpsProcess;
    _methods[ "sell-amps"] =      &Msgs::sellAmpsProcess;
    _methods[ "ac-volts-out"] =   &Msgs::acVoltsOutProcess;
    _methods[ "ac1-volts-in"] =   &Msgs::ac1InProcess;
    _methods[ "ac2-volts-in"] =   &Msgs::ac2InProcess;
  
    // Status messages on the system
    _methods[ "status"] = &Msgs::statusProcess;
    _methods[ "version"] = &Msgs::statusProcess;
    _methods[ "revision"] = &Msgs::statusProcess;
    _methods[ "opmode"] = &Msgs::statusProcess;
    _methods[ "errormode"] = &Msgs::statusProcess;
    _methods[ "warningmode"] = &Msgs::statusProcess;

    // Configuration settings
    _methods[ "config"] = &Msgs::configProcess;
    _methods[ "generator"] = &Msgs::configProcess;
    _methods[ "grid"] = &Msgs::configProcess;
    _methods[ "buy"] = &Msgs::configProcess;
    _methods[ "sell"] = &Msgs::configProcess;
    _methods[ "start"] = &Msgs::configProcess;
    _methods[ "end"] = &Msgs::configProcess;

    // Command messages
    _methods[ "command"] = &Msgs::commandProcess;
//   _methods[ "auxilary"] = &Msgs::commandAuxilaryProcess;
//   _methods[ "relay"] = &Msgs::commandRelayProcess;
//   _methods[ "poll"] = &Msgs::commandPollProcess;;
//   _methods[ "inverter"] = &Msgs::commandInverterProcess;;
//   _methods[ "charger"] = &Msgs::commandChargerProcess;;
    // _methods[ "restart"] = &Msgs::commandRestartProcess;;
    _methods[ "auxilary"] = &Msgs::commandProcess;
    _methods[ "relay"] = &Msgs::commandProcess;
    _methods[ "poll"] = &Msgs::commandProcess;
    _methods[ "inverter"] = &Msgs::commandProcess;
    _methods[ "charger"] = &Msgs::commandProcess;
  
    //  _methods[""] = &Msgs::unimplementedProcess;

    // preload a few values
    if (_net_mode == DAEMON) {
        _cache[ "version"] = VERSION;
        _cache[ "revision"] = VERSION;
//     _cache[ "opmode"] = "unknown";
//     _cache[ "errormode"] = "unknown";
//     _cache[ "warningmode"] = "unknown";

        // FIXME: fake meter values!
        // Meters
        _cache[ "battery-volts"] = "88888888";
        _cache[ "charge-amps"] = "777777777";
        _cache[ "load-amps"] = "66666666";
        _cache[ "pv-amps"] = "55555555";
        _cache[ "sell-amps"] = "444444444444";
    }
  
    errc::make_error_code(errc::success);
}

std::string &
Msgs::cacheGet(const std:;string &name) {
    // DEBUGLOG_REPORT_FUNCTION;
#if 1
    const char         *tag;
    std::string                str;
  
    _body.str("");
    std::map<const std::string, std::string>::const_iterator it;
    for (it = _cache.begin(); it != _cache.end(); it++) {
        //entry = it->second;
        tag = it->first;
        str  = it->second;
        _body.str("");
        if (strcmp(tag, name) == 0) {
            if (str.size() != 0) {
                _body << " Has data: " << str;
            } else {
                BOOST_LOG(lg) << " doesn't have data";
                return _body.str();
            }
            return str;
        }
        BOOST_LOG(lg) << "Looking for cache value for XML Tag \"" << tag
                   << "\" has " << _body.str().c_str() << std::endl;
    }
    return _body.str();
#else
    return _cache[name];
#endif
}

boost::system::error_code
Msgs::cacheAdd(const std::string &name, const std::string &str)
{
    // DEBUGLOG_REPORT_FUNCTION;
    _cache[name] = str;

    // FIXME: we should make sure this actually worked.
    errc::make_error_code(errc::success);
}


// Add a function for handling an XML tag to the list.
void
Msgs::methodSet(const cstd::string &name, methodPtr_t func)
{
    // DEBUGLOG_REPORT_FUNCTION;
    _methods[name] = func;
}

// Get the function for an XML tag from the list.
Msgs::methodPtr_t
Msgs::methodGet(const std::string &name)
{
    //DEBUGLOG_REPORT_FUNCTION;
#if 1
    const char         *str;
    Msgs::methodPtr_t     ptr;
  
    std::map<const char *, Msgs::methodPtr_t>::const_iterator it;
    for (it = _methods.begin(); it != _methods.end(); it++) {
        //entry = it->second;
        str = it->first;
        ptr  = it->second;
        _body.str("");
        if (ptr != 0) {
            _body << " a function pointer";
        } else {
            _body << " doesn't have a function pointer";
        }
        //     BOOST_LOG(lg) << "Looking for method for XML Tag \"" << name.c_str()
        //                << "\" has " << _body.str().c_str() << std::endl;
        if (strcmp(str, name) == 0) {
            return ptr;
        }
    }
#else
    BOOST_LOG(lg) << "\"" << name << "\" method we want" << std::endl;
    return _methods[name];
#endif
    //return (methodPtr_t *)0;
}

// Call the function to process an XML node
boost::system::error_code
Msgs::methodProcess(const std::string &name, XMLNode &node)
{
    // DEBUGLOG_REPORT_FUNCTION;
    //(this->*_methods.find(name)(node); 
    return (this->*_methods[name])(node);
}

// Dump all the pointer to methods for each XML Tag
void
Msgs::methodsDump(void)
{
    DEBUGLOG_REPORT_FUNCTION;
    const char         *name;
    Msgs::methodPtr_t     ptr;
  
    BOOST_LOG(lg) << "We have " << (int)_methods.size() << " in function table" << std::endl;
  
    std::map<const char *, Msgs::methodPtr_t>::const_iterator it;
    for (it = _methods.begin(); it != _methods.end(); it++) {
        name = it->first;
        ptr  = it->second;
        _body.str("");
        if (ptr != 0) {
            _body << "a method pointer";
        } else {
            _body << "no pointer to method";
        }
        BOOST_LOG(lg) << "XML Tag \"" << name
                   << "\" has " << _body.str().c_str() << std::endl;
    }
}

// Dump all the pointer to methods for each XML Tag
void
Msgs::cacheDump(void)
{
    DEBUGLOG_REPORT_FUNCTION;
    const char         *name;
    std::string                data;
  
    BOOST_LOG(lg) << "We have " << (int)_cache.size() << " items in the cache" << std::endl;
  
    std::map<const std::string, std::string &>::const_iterator it;
    for (it = _cache.begin(); it != _cache.end(); it++) {
        name = it->first;
        data  = it->second;
        _body.str("");
        if (data.size() != 0) {
            _body << "data is " << data;
        } else {
            _body << "no data";
        }
        BOOST_LOG(lg) << "XML Tag \"" << name
                   << "\" has " << _body.str().c_str() << std::endl;
    }
}

Msgs::~Msgs()
{
    // DEBUGLOG_REPORT_FUNCTION;
  
}

boost::system::error_code
Msgs::unimplementedProcess(XMLNode *xml)
{
    DEBUGLOG_REPORT_FUNCTION;

    BOOST_LOG(lg) << "XML tag \"" << xml->nameGet() << "\" doesn't exist." << std::endl;

    _body.str("");                // erase the current string
    _body << "<powerguru version=\"" << _version << "\">";
    _body << "<status><warningmode><";
    _body <<  xml->nameGet();
    _body << ">unimplemented</" <<  xml->nameGet();
    _body <<  "></warningmode>" << "</status>"; 
    _body << "</powerguru>";
    _body << ends;

    if (writeNet(_body.str())) {
        errc::make_error_code(errc::not_supported);
    } else {
        errc::make_error_code(errc::success);
    }
}

void
Msgs::process(XMLNode *xml)
{
    DEBUGLOG_REPORT_FUNCTION;
    methodPtr_t   fptr;
    const char *str;
    boost::system::error_code     ret;
    int           i;

    str = xml->nameGet();
    fptr = methodGet(str);
    //methodsDump();
  
    if (fptr != 0) {
        BOOST_LOG(lg) << "XML tag \"" << str << "\" has method pointer" << std::endl;
        ret = (this->*fptr)(xml);
    } else {
        BOOST_LOG(lg) << "WARNING: XML tag \"" << str << "\" doesn't have a method pointer" << std::endl;
    }

    if (ret < 0) {
        BOOST_LOG(lg) << "ERROR: Got an error from executing function pointer!" << std::endl;
    } else {    
        BOOST_LOG(lg) << "executed function pointer successfully!" << std::endl;
    }
  
    // Process the children too
    for (i=0; i<xml->childrenSize(); i++) {
        process(xml->childGet(i));
    }  
}

void
Msgs::dump(XMLNode *xml)
{
    // DEBUGLOG_REPORT_FUNCTION;
    int           child,  i;
    XMLNode       *childnode;

    BOOST_LOG(lg) << "processing node " << xml->nameGet() << std::endl;

    // Process the node's value, if it has one.
    if (xml->valueGet() == 0) {
        BOOST_LOG(lg) << "No content for node " << xml->nameGet() << std::endl;
    } else {
        BOOST_LOG(lg) << "Content for node " << xml->nameGet()
                   << " is " << xml->valueGet() << std::endl;
    }
  
    // Process the attributes, if any
    if (xml->attributesSize() == 0) {
        BOOST_LOG(lg) << "\tNo attributes for node " << xml->nameGet() << std::endl;
    } else {
        for (i=0; i<xml->attributesSize(); i++) {
            BOOST_LOG(lg) << "\tAttribute is " << xml->attribGet(i)->nameGet()
                       << " who's value is " << xml->attribGet(i)->valueGet() << std::endl;
        }
    }

    // Process the children, if there are any
    if (xml->childrenSize()) {
        BOOST_LOG(lg) << "\tProcessing " << xml->childrenSize() << " children nodes for "
                   << xml->nameGet() << std::endl;
        for (child=0; child<xml->childrenSize(); child++) {
            childnode = xml->childGet(child);
            dump(childnode); // setup child node
        }
    } else {
        BOOST_LOG(lg) << "Node " << xml->nameGet() << " has no children" << std::endl;
    }
}

// These format client side messages to the daemon
std::string &
Msgs::statusCreate(meter_data_t *md)
{
    DEBUGLOG_REPORT_FUNCTION;
#if 1
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\">";
    _body << "<status>" << "</status>"; 
    _body << "</powerguru>";
    _body << ends;
  
    return _body.str();
#else
    int rc;
    xmlTextWriterPtr writer;
    xmlBufferPtr buf;
    char *tmp;
  
    if ((buf = xmlBufferCreate()) == NULL) {
        printf("testXmlwriterMemory: Error creating the xml buffer\n");
        return "";
    }
  
    if ((writer = xmlNewTextWriterMemory(buf, 0)) == NULL) {
        printf("testXmlwriterMemory: Error creating the xml writer\n");
        return "";
    }
  
    /* Start the document with the xml default for the version,
     * encoding ISO 8859-1 and the default for the standalone
     * declaration. */
    if ((rc = xmlTextWriterStartDocument(writer, NULL, MY_ENCODING, NULL)) < 0) {
        printf("testXmlwriterMemory: Error at xmlTextWriterStartDocument\n");
        return "";
    }
  
    if ((rc = xmlTextWriterStartElement(writer,  "powerguru")) < 0) {
        printf
            ("testXmlwriterMemory: Error at xmlTextWriterStartElement\n");
        return "";
    }
  
    if ((rc = xmlTextWriterStartElement(writer,  "status")) < 0) {
        printf
            ("testXmlwriterMemory: Error at xmlTextWriterStartElement\n");
        return "";
    }
    
    /* Add an attribute with name "version" and value "1.0" to status. */
    if ((rc = xmlTextWriterWriteAttribute(writer,  "version",
                                           "1.0")) < 0) {
        printf
            ("testXmlwriterMemory: Error at xmlTextWriterWriteAttribute\n");
        return "";
    }
  
    // end status tag
    if ((rc = xmlTextWriterEndElement(writer)) < 0) {
        printf("testXmlwriterMemory: Error at xmlTextWriterEndElement\n");
        return "";
    }
  
    /* Close the element named FOOTER. */
    if ((rc = xmlTextWriterEndElement(writer)) < 0) {
        printf("testXmlwriterMemory: Error at xmlTextWriterEndElement\n");
        return "";
    }
  
    if ((rc = xmlTextWriterEndDocument(writer)) < 0) {
        printf("testXmlwriterMemory: Error at xmlTextWriterEndDocument\n");
        return "";
    }
  
    xmlFreeTextWriter(writer);
  
    //    cerr << "Buffer says: " << (const char *) buf->content << std::endl;
    std::string str = (const char *) buf->content;
    xmlBufferFree(buf);
    return str;
#endif  
}

// Say "helo" to the connecting program to establish the messaging
// system. Both ends of the connection use this string to make sure
// they are speaking the same version of the protocol.
std::string &
Msgs::heloCreate(float version)
{
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\">";
    _body << "<client ip=\"" << _remoteip << "\">" << _remotehost << "</client>"; 
    _body << "<server ip=\"" << _thisip   << "\">" << _thishost   << "</server>"; 
    _body << "</powerguru>";
    _body << ends;

    return _body.str();
}

std::string &
Msgs::metersRequestCreate(std::string str) {
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\">";
    _body << "<meters>" << str.c_str() << "</meters>"; 
    _body << "</powerguru>";
    _body << ends;

    return _body.str();  
}

std::string &
Msgs::metersRequestCreate(xml_meters_e val) {
    DEBUGLOG_REPORT_FUNCTION;
    std::string str;

    switch (val) {
      case CHARGE_AMPS:
          str = "charge-amps";
          break;
      case AC_LOAD_AMPS:
          str = "load-amps";
          break;
      case BATTERY_VOLTS:
          str = "battery-volts";
          break;
      case AC_VOLTS_OUT:
          str = "ac-volts-out";
          break;
      case AC1_VOLTS_IN:
          str = "ac1-volts-in";
          break;
      case AC2_VOLTS_IN:
          str = "ac2-volts-in";
          break;
      case PV_AMPS_IN:
          str = "pv-amps-in";
          break;
      case PV_VOLTS_IN:
          str = "pv-volts-in";
          break;
      case BUY_AMPS:
          str = "buy-amps";
          break;
      case SELL_AMPS:
          str = "sell-amps";
          break;
      case DAILY_KWH:
          str = "daily-kwh";
          break;
      case HERTZ:
          str = "hertz";
          break;
      case TEMPCOMP_VOLTS:
          str = "tempcomp";
          break;
      default:
          break;                      // you should never be
    };

    return metersRequestCreate(str);
}

std::string
Msgs::metersResponseCreate(const std::string &type, int val) {
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\">";
    _body << "<meters><" << (const char *)type << ">";
    _body << val;
    _body << "</" << (const char *)type << ">" << "</meters>"; 
    _body << "</powerguru>";
    _body << ends;

    return _body.str();  
}

std::string
Msgs::metersResponseCreate(const std::string &type, float val) {
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\">";
    _body << "<meters><" << (const char *)type << ">";
    _body << val;
    _body << "</" << (const char *)type << ">" << "</meters>"; 
    _body << "</powerguru>";
    _body << ends;

    return _body.str();  
}

std::string
Msgs::metersResponseCreate(const char *type, string val) {
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\">";
    _body << "<meters><" << (const char *)type << ">";
    _body << val;
    _body << "</" << (const char *)type << ">" << "</meters>"; 
    _body << "</powerguru>";
    _body << ends;

    return _body.str();  
}

std::string
Msgs::requestCreate(xml_meters_e tag)
{
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"" << _version << "\"><meters>";
    switch (tag) {
      case CHARGE_AMPS:
          _body << "charge-amps";
          break;
      case AC_LOAD_AMPS:
          _body << "load-amps";
          break;
      case BATTERY_VOLTS:
          _body << "battery-volts";
          break;
      case AC_VOLTS_OUT:
          _body << "ac-volts-out";
          break;
      case AC1_VOLTS_IN:
          _body << "ac1-volts-in";
          break;
      case AC2_VOLTS_IN:
          _body << "ac2-volts-in";
          break;
      case PV_AMPS_IN:
          _body << "pv-amps-in";
          break;
      case PV_VOLTS_IN:
          _body << "pv-volts-in";
          break;
      case BUY_AMPS:
          _body << "buy-amps";
          break;
      case SELL_AMPS:
          _body << "sell-amps";
          break;
      case DAILY_KWH:
          _body << "daily-kwh";
          break;
      case HERTZ:
          _body << "hertz";
          break;
      case TEMPCOMP_VOLTS:
          _body << "tempcomp";
          break;
      default:
          break;                      // you should never be
    };
    _body << "</meters></powerguru>";
    _body << ends;

    return _body.str();  
}

string
Msgs::requestCreate(xml_status_e tag)
{
    DEBUGLOG_REPORT_FUNCTION;

    _body.str("");                // erase the current string
    _body << "<powerguru version=\"" << _version << "\"><status>";
    switch (tag) {
      case SYSVERSION:
          _body << "sysversion";
          break;
      case REVISION:
          _body << "revision";
          break;
      case ERRORMODE:
          _body << "errormode";
          break;
      case WARNINGMODE:
          _body << "warningmode";
          break;
      case OPMODE:
          _body << "opmode";
          break;
      default:
          break;
    };
    _body << "</status></powerguru>";

    _body << ends;  

    return _body.str();  
}

string
Msgs::requestCreate(xml_config_e tag)
{
    DEBUGLOG_REPORT_FUNCTION;  

    _body.str("");                // erase the current string
    _body << "<powerguru version=\"" << _version << "\"><config>";
    switch (tag) {
      case GENCONFIG:
          _body << "generator";
          break;
      case GRIDCONFIG:
          _body << "grid";
          break;
      case BUY:
          _body << "buy";
          break;
      case SELL:
          _body << "sell";
          break;
      case CHARGE:
          _body << "charge";
          break;
      default:
          break;
    };
    _body << "</config></powerguru>";

    _body << ends;  

    return _body.str();  
}

string
Msgs::requestCreate(xml_command_e tag)
{
    DEBUGLOG_REPORT_FUNCTION;

    _body.str("");                // erase the current string
    _body << "<powerguru version=\"" << _version << "\"><status>";
    switch (tag) {
      case GENERATOR:
          _body << "generator";
          break;
      case GRID:
          _body << "grid";
          break;
      case RELAY:
          _body << "relay";
          break;
      case AUXILARY:
          _body << "auxilary";
          break;
      case POLL:
          _body << "poll";
          break;
      case INVERTER:
          _body << "inverter";
          break;
      case CHARGER:
          _body << "charger";
          break;
      default:
          break;
    };
    _body << "</status></powerguru>";

    _body << ends;  

    return _body.str();  
}


std::string
Msgs::responseCreate(xml_msg_e type, const std::string &tag, std::string &val)
{
    DEBUGLOG_REPORT_FUNCTION;
    std::string str;
  
    switch (type) {
      case HEARTBEAT:
          str = "heartbeat";
          break;
      case STATUS:
          str = "status";
          break;
      case METER:
          str = "meters";
          break;
      case CONFIG:
          str = "config";
          break;
      case COMMAND:
          str = "command";
          break;
      case RESPONSE:
          str = "response";
          break;
    };
  
    _body.str("");                // erase the current string
    _body << "<powerguru version=\"";
    _body << _version << "\"><" << str;
    _body << "><" << (const char *)tag << ">";
    _body << val;
    _body << "</" << (const char *)tag << "></" << str; 
    _body << "></powerguru>";
    _body << ends;

    return _body.str();  
}

string
Msgs::configCreate(string tag, int value)
{
    DEBUGLOG_REPORT_FUNCTION;
    _body.str("");                // erase the current string
    _body << "<powerguru>";
    _body << "<" << tag << ">" << value << "</" << tag << ">";
    _body << "</powerguru>";
    _body << ends;
  
    return _body.str();
}

void
Msgs::print_msg(std::string msg)
{
    // DEBUGLOG_REPORT_FUNCTION;
    int level = 1;
    int start = 0;
    size_t pos;
    std::string str, prefix, newmsg;
    const char *tabs[] = {
        "\r\n\t",
        "\r\n\t\t",
        "\r\n\t\t\t",
        "\r\n\t\t\t\t",
        "\r\n\t\t\t\t",
        "\r\n\t\t\t\t\t",
    };
  
    xmlDebugDumpString(stderr, (const xmlChar *)msg.c_str());
    //  cerr << "++++++++++++++++++++++" << std::endl;
  
    // Strip off the DTD header, as we're not bothering to validate
    // our XML.
    if ((pos = msg.find("?>\n", start)) != std::string::npos) {
        newmsg = msg.substr(pos+3, msg.size());
    } else {
        newmsg = msg;
    }  

    start = 0;
    while ((pos = newmsg.find('\n', start)) != std::string::npos) {
        newmsg.erase(pos, 1);
    }  

//   while ((pos = newmsg.find("><", start)) != std::string::npos) {
//     newmsg.insert(pos+1, "GGGGGG");
//   }  

    start = 0;
    while ((pos = newmsg.find('>', start)) != std::string::npos) {
        str = newmsg.substr(start, newmsg.find('>', start) - start + 1);
        start += str.size();
        if ((pos = str.rfind(">", start)) != std::string::npos) {
            //      str.insert(pos+1, "FFFF");
            str.insert(pos+1, tabs[level]);
            level++;
        }
        if ((pos = str.rfind("</", start)) != std::string::npos) {
            //      cerr << "EEEE";
            //      str.insert(pos, "EEEE");
            level--;
            str.insert(pos, tabs[level]);
        }
      
        cerr << str;
        //    cerr << prefix << str;
    }
    //cerr << newmsg.substr(start, newmsg.size()) << std::endl;
}

// These parse incoming messages for the daemon
boost::system::error_code
Msgs::statusProcess(XMLNode &node)
{
    DEBUGLOG_REPORT_FUNCTION;
    //  XMLNode *child;
    //  xmlChar i;
    std::string str;
    _body.str("");
    _body << _version;

    // BOOST_LOG(lg) <<  node->valueGet() << std::endl;
  
    if (_net_mode == DAEMON) {
        if (strcmp(node->valueGet(),  "sysversion") == 0) {
            str = responseCreate(STATUS, node->valueGet(), _body.str().c_str());
        } else if (strcmp(node->valueGet(),  "revision") == 0) {
            str = responseCreate(STATUS, node->valueGet(), "0.0");
        } else if (strcmp(node->valueGet(),  "opmode") == 0) {
            str = responseCreate(STATUS, node->valueGet(), "none");
        } else if (strcmp(node->valueGet(),  "warningmode") == 0) {
            str = responseCreate(STATUS, node->valueGet(), "none");    
        } else if (strcmp(node->valueGet(),  "errormode") == 0) {
            str = responseCreate(STATUS, node->valueGet(), "none");
        }
    
        if (writeNet(str)) {
            errc::make_error_code(errc::not_supported);
        } else {
            errc::make_error_code(errc::success);
        }
    }

    if (_net_mode == CLIENT) {
        if (strcmp(node->nameGet(),  "status") == 0) {
            errc::make_error_code(errc::success);
        }

#if 0
        if        (strcmp(node->nameGet(),  "revision") == 0) {
            //cerr << "VER" << std::endl;
        } else if (strcmp(node->nameGet(),  "sysversion") == 0) {
            //cerr << "REV" << std::endl;
        } else if (strcmp(node->nameGet(),  "opmode") == 0) {
            //cerr << "OP" << std::endl;
        } else if (strcmp(node->nameGet(),  "warningmode") == 0) {
            //cerr << "WARN" << std::endl;
        } else if (strcmp(node->nameGet(),  "errormode") == 0) {
            //cerr << "ERROR" << std::endl;
        }
#endif

        cacheAdd(node->nameGet(), node->valueGet());
        BOOST_LOG(lg) << "tag \"" << node->nameGet() << "\" has a value of: " << node->valueGet() << std::endl;
    
        errc::make_error_code(errc::success);
    }
  
    errc::make_error_code(errc::not_supported);                 // FIXME: implement this method
}

boost::system::error_code
Msgs::heloProcess(XMLNode &node)
{
    DEBUGLOG_REPORT_FUNCTION;
    BOOST_LOG(lg) << "WARNING: unimplemented method" << std::endl;
  
    errc::make_error_code(errc::not_supported);                 // FIXME: implement this method
}

boost::system::error_code
Msgs::configProcess(XMLNode &node)
{
    DEBUGLOG_REPORT_FUNCTION;

    return unimplementedProcess(node);    // FIXME: implement this method
}

boost::system::error_code
Msgs::metersProcess(XMLNode &node)
{
    DEBUGLOG_REPORT_FUNCTION;

    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet()
               << " and mode is: " << (int)_net_mode << std::endl;

    if(_net_mode == DAEMON) {
        //cacheDump();
        //    const unsigned char *xxx = node->nameGet();
        std::string value = cacheGet(node->valueGet());
        BOOST_LOG(lg) << "value for \"" << node->valueGet() << "\" is " << value.c_str() << std::endl;
        if (value.size() == 0) {
        } else {
      
        }
  
        std::string str = metersResponseCreate(node->valueGet(), value);
        if (writeNet(str)) {
            errc::make_error_code(errc::not_supported);
        } else {
            errc::make_error_code(errc::success);
        }
    }

    if (_net_mode == CLIENT) {
        //BOOST_LOG(lg) << node->valueGet()
        // Process the result
    }

    errc::make_error_code(errc::not_supported);
}

boost::system::error_code
Msgs::serverProcess(XMLNode &node)
{
    //  DEBUGLOG_REPORT_FUNCTION;
    XMLAttr *attr;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->hasAttributes()) {
        if ((attr = node->attribGet(0))) {
            BOOST_LOG(lg) << "\tAttribute is \"" << attr->nameGet()
                       << "\" with a value of " << attr->valueGet() << std::endl;
            if (strcmp(attr->valueGet(), (const char *)_thisip.c_str()) != 0) {
                BOOST_LOG(lg) << "WARNING: IP's don't match!!!!" << std::endl;
                errc::make_error_code(errc::not_supported);
            }
        }
    }

    if (strcmp(node->valueGet(), (const char *)_thishost.c_str()) != 0) {
        BOOST_LOG(lg) << "WARNING: Host's don't match!!!!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }

    BOOST_LOG(lg) << "Host and IP data match" << std::endl;
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::clientProcess(XMLNode &node)
{
    // DEBUGLOG_REPORT_FUNCTION;
    XMLAttr *attr;

    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (_remoteip.size() > 0) {
        if (node->hasAttributes()) {
            if ((attr = node->attribGet(0))) {
                BOOST_LOG(lg) << "\tAttribute is \"" << attr->nameGet()
                           << "\" with a value of " << attr->valueGet() << std::endl;
                if (strcmp(attr->valueGet(), (const char *)_remoteip.c_str()) != 0) {
                    BOOST_LOG(lg) << "WARNING: IP's don't match!!!!" << std::endl;
                    errc::make_error_code(errc::not_supported);
                }
            }
        }
    }

    if (_remotehost.size() != 0) {
        if (strcmp(node->valueGet(), (const char *)_remotehost.c_str()) != 0) {
            BOOST_LOG(lg) << "WARNING: Host's don't match!!!!" << std::endl;
            errc::make_error_code(errc::not_supported);
        }
    }

    errc::make_error_code(errc::success);
}

// Process the top level header tag.
boost::system::error_code
Msgs::powerguruProcess(XMLNode &node)
{
    DEBUGLOG_REPORT_FUNCTION;
    XMLAttr *attr;

    _body.str("");
    _body << _version;
  
//   BOOST_LOG(lg) << "Node is \"" << node->nameGet()
//              << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->hasAttributes()) {
        if ((attr = node->attribGet(0))) {
//       BOOST_LOG(lg) << "\tAttribute is \"" << attr->nameGet().c_str()
//                  << "\" with a value of " << attr->valueGet().c_str() << std::endl;
            if (strcmp((const char *)_body.str().c_str(), (const char*)attr->valueGet()) != 0) {
                BOOST_LOG(lg) << "Versions in header don't match!" << std::endl;
            } else {
                BOOST_LOG(lg) << "Versions in header match" << std::endl;
            }
        }
    }

    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::chargeAmpsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::loadAmpsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        //    errc::make_error_code(errc::not_supported);
    }
  
    if (_net_mode == CLIENT) {
        BOOST_LOG(lg) << "Battery voltage is: " << node->valueGet() << std::endl;
    
        errc::make_error_code(errc::success);
    }

#if 0
    if (_net_mode == DAEMON) {
        std::string str = metersResponseCreate(node->valueGet(), _cache[node->nameGet()]);
    
        errc::make_error_code(errc::success);
    }
#endif
    
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::pvAmpsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::pvVoltsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::dailyKwhProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::hertzProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::batteryVoltsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
//   BOOST_LOG(lg) << "Node is \"" << node->nameGet()
//              << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        //    errc::make_error_code(errc::not_supported);
    }

    if (_net_mode == CLIENT) {
        BOOST_LOG(lg) << "Battery voltage is: " << node->valueGet() << std::endl;
    
        errc::make_error_code(errc::success);
    }

#if 0
    if (_net_mode == DAEMON) {
        std::string str = metersResponseCreate(node->valueGet(), _cache[node->nameGet()]);
    
        errc::make_error_code(errc::success);
    }
#endif
    
    errc::make_error_code(errc::not_supported);
}

boost::system::error_code
Msgs::buyAmpsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::sellAmpsProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::acVoltsOutProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}
  
boost::system::error_code
Msgs::ac1InProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::ac2InProcess(XMLNode &node) {
    DEBUGLOG_REPORT_FUNCTION;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }
      
    errc::make_error_code(errc::success);
}

boost::system::error_code
Msgs::findTag(std::string tag)
{
    DEBUGLOG_REPORT_FUNCTION;
    size_t pos;

    _body.str("");

    _body << "<" << tag << ">";
    if ((pos = tag.find(_body.str(), 0)) != std::string::npos) {
        errc::make_error_code(errc::success);
    }
    errc::make_error_code(errc::not_supported);
}


boost::system::error_code
Msgs::commandProcess(XMLNode &node)
{
    DEBUGLOG_REPORT_FUNCTION;
    std::string str;
  
    BOOST_LOG(lg) << "Node is \"" << node->nameGet()
               << "\" with a value of " << node->valueGet() << std::endl;
      
    if (node->valueGet() <= 0) {
        BOOST_LOG(lg) << "ERROR: no value in messages!" << std::endl;
        errc::make_error_code(errc::not_supported);
    }

    _body.str("");
    _body << _version;

    // BOOST_LOG(lg) <<  node->valueGet() << std::endl;

    if (_net_mode == DAEMON) {
        if (strcmp(node->valueGet(), "auxilary") == 0) {
            str = responseCreate(COMMAND, node->valueGet(), "0.0");
        } else if (strcmp(node->valueGet(), "relay") == 0) {
            str = responseCreate(COMMAND, node->valueGet(), "none");
        } else if (strcmp(node->valueGet(), "poll") == 0) {
            str = responseCreate(COMMAND, node->valueGet(), "inverter");    
        } else if (strcmp(node->valueGet(), "") == 0) {
            str = responseCreate(COMMAND, node->valueGet(), "charger");
        } else {
            BOOST_LOG(lg) << "VALUEGET: " << node->valueGet() << std::endl;
            str = responseCreate(RESPONSE, node->valueGet(), "foobar");
        }
        if (writeNet(str + "\r\n")) {
            errc::make_error_code(errc::not_supported);
        } else {
            errc::make_error_code(errc::success);
        }
    }

    if (_net_mode == CLIENT) {
        if (strcmp(node->nameGet(), "command") == 0) {
            errc::make_error_code(errc::success);
        }
        cacheAdd(node->nameGet(), node->valueGet());
        BOOST_LOG(lg) << "tag \"" << node->nameGet() << "\" has a value of: " << node->valueGet() << std::endl;
    
        errc::make_error_code(errc::success);
    }

    errc::make_error_code(errc::not_supported);  
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
