// 
// Copyright (C) 2005, 2006 - 2018
//      Free Software Foundation, Inc.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// This is generated by autoconf.
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <string>
#include <cstring>
#include <vector>
#include <cstdlib>
#include <unistd.h>

#include <iostream>
#include <fstream>

#ifdef HAVE_GETOPT_H
#include <getopt.h>
#else
extern int optind;
extern char *optarg;
#endif

// local header files
#include "log.h"
#include "outbackpower.h"
#include "console.h"
#include "fakeuart.h"
#include "rc.h"

using namespace rcinit;

static void usage (const std::string &);
extern LogFile dbglogfile;
 
retcode_t sim_mx(const std::string &filespec);
retcode_t sim_fx(const std::string &filespec);

int
main(int argc, char *argv[])
{
    int c, i, ch, ret;
    std::string device;
    outback_type_t otype;
    
    if (argc == 1) {
        //usage(argv[0]);
    }

    // Load the database config variable so they can be overridden by
    // the command line arguments.
    RCinitFile config;
    config.load_files();
    if (config.deviceGet().size() > 0) {    
      device = config.deviceGet();
    } else {
        device = DEFAULT_UART;
    }

    // Default to being an MX charge controller device
    otype = OUTBACK_MX;
    
    // Process the command line arguments.
    while ((c = getopt (argc, argv, "hvd:t:")) != -1) {
      switch (c) {
      case 'h':
	usage (argv[0]);
	break;

      case 'v':
        // verbosity++;
	dbglogfile.set_verbosity();
	BOOST_LOG(lg) << "Verbose output turned on" << std::endl;
	break;
        
      case 'd':
	device = strdup(optarg);
	break;

      case 't':
        if (memcmp(optarg, "mx", 2) == 0) {
          otype = OUTBACK_MX;
        } else if (strncmp(optarg, "fx", 2) == 0) {
          otype = OUTBACK_MX;
        } else {
            std::cerr << "ERROR: No Device Type specified, \"" << optarg << "\" is bogus!" << std::endl;
          exit(-1);
        }
        
	break;

      default:
	usage (argv[0]);
        break;
      }
    }

    // Say which device we're simulating
    if (otype == OUTBACK_MX) {
      BOOST_LOG(lg) << "Simulating a Outback MX60 charge controller" << std::endl;
      sim_mx(device);
    }
    if (otype == OUTBACK_FX) {
      BOOST_LOG(lg) << "Simulating a Outback FX Series Inverter" << std::endl;
      sim_fx(device);
    }

    exit(0);
}

static void
usage (const std::string &prog)
{
    std::cerr <<"This program implements a command line interface" << std::endl; 
    std::cerr << "for an Outback Power Systems Device" << std::endl;
    std::cerr << "Usage: " << prog << " [hvd]" << std::endl;
    std::cerr << "\t-h\t\t\t\tHelp (this display)" << std::endl;
    std::cerr << "\t-v\t\t\t\tVerbose mode" << std::endl;
    std::cerr << "\t-d [filespec]\t\t\tSpecify Serial Port (default=/dev/ttyS0)" << std::endl;
    std::cerr << "\t-t [t]\t\t\t\tSpecify Device Type (default=mx)" << std::endl;
    
    exit (-1);
}

retcode_t
sim_mx(const std::string &device)
{
    //struct stat stats;
    std::string datafile;
    std::string home;
    std::string line, newline;
    std::ifstream in;
    FakeUart fu;
    if (device.empty()) {
        return ERROR;
    }
    
    // See if it exists in the right place
    fu.Open();
    
    // Check the users home directory for the data file
    datafile = std::getenv("HOME");
    datafile += "/.powerguru/mx60.data";
    
    //BOOST_LOG(lg) << "Seeing if the TTY "<< device << " exists." << std::endl;
    //if (stat(datafile.c_str(), &stats) == 0) {
    in.open(datafile);
    if (!in) {
        BOOST_LOG(lg) << "ERROR: Couldn't open datafile: " << datafile << std::endl;
        return ERROR;
    } else {
        BOOST_LOG(lg) << "Opened datafile: " << datafile << std::endl;
    }
        
    // Read in each line and send it
    while (getline(in, line)) {
        //newline = '*';
        newline = line;
        newline += "\r\n";
        std::cout << newline;
        fu.Write(newline);
        // All outback products send their data at 1 second intervals
        sleep(1);
    }
 
    in.close();
    return ERROR;
}

retcode_t
sim_fx(const std::string &device)
{
    return ERROR;
}

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
