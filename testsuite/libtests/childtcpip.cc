// 
//   Copyright (C) 2005,2006-2018 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdarg.h>
#include <signal.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <cstdio>
#include <iostream>
#include <vector>

#include "dejagnu.h"
#include "tcpip.h"

int verbosity;
static void usage (void);
bool waitforgdb = false;

int proc_tests (const std::string &procname);
int start_proc (const std::string &procname);

TestState runtest;

int
main(int argc, char *argv[])
{
    int c;
    bool dump = false;
    std::string filespec;
    
    while ((c = getopt (argc, argv, "hdvs:")) != -1) {
        switch (c) {
          case 'h':
            usage ();
            break;
          case 'd':
            dump = true;
            break;
          case 's':
            waitforgdb = true;
            break;
          case 'v':
            verbosity++;
            break;
          default:
            usage ();
            break;
        }
    }
    
    Tcpip tcpip;
    retcode_t ts = tcpip.createNetClient(DEFAULTPORT);

    tcpip.writeNet("foo");

    std::vector<unsigned char> data;
    tcpip.readNet(data);
    if (data.size() > 0) {
        std::cout << "Child read " << data.size() <<" bytes from parent:" << std::endl;
        runtest.pass("child readNet");
    } else {
        runtest.fail("child readNet()");
    }  
}

static void
usage (void)
{
    std::cerr << "This program tests the tcpip subsystem." << std::endl;
    std::cerr << "Usage: childtcpip [h]" << std::endl;
    std::cerr << "-h\tHelp" << std::endl;
    std::cerr << "-d\tDump parsed data" << std::endl;
    exit (-1);
}
