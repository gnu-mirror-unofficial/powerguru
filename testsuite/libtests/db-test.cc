// 
//   Copyright (C) 2018, 2019 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <string>
#include <vector>
#include <boost/shared_ptr.hpp>
#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>
#include "dejagnu.h"
#include "database.h"
#include "log.h"
#include "onewire.h"

int verbosity;
static void usage (void);
bool waitforgdb = false;

TestState runtest;

Database::~Database() {
        DEBUGLOG_REPORT_FUNCTION;
};

// Declare a class inherited from the base class so we can access the internal
// protected data.
class Test : public Database {
public:
    Test() {
        DEBUGLOG_REPORT_FUNCTION;

        std::string result;
        // Test creating commands
        std::cerr << gettime(result) << std::endl;
        
        if (boost::regex_match(result, boost::regex("[0-9 :-]*"))) {
            runtest.pass("gettime()");
        } else {
            runtest.fail("gettime())");
        }

        std::vector<std::string> items;

        // family | id | alias | chips | type | timestamp 
        result.clear();
        boost::shared_ptr<onewire_t> one(new onewire_t);
        one->family = "24";
        one->id = "97C6697351AB";
        one->alias = "";
        one->chips = "DS2415";
        one->type = CLOCK;
        formatQuery(one, result);

        boost::split(items, result, boost::is_any_of(","));        
        std::cerr << items[1] << std::endl;        
        if (items[0] == "'24'"
            && items[1] == " '97C6697351AB'"
            && items[3] == " 'DS2415'"
            && items[4] == " CLOCK"
        ) {
            runtest.pass("formatQuery(onewire_t)");
        } else {
            runtest.fail("formatQuery(onewire_t)");
        }        
        
        // Reset the output buffer and test formatting a temperature entry
        //  id | temperature | temphigh | templow | scale | timestamp
        result.clear();
        boost::shared_ptr<temperature_t> temp(new temperature_t);
        temp->id = "67C6697351FF";
        temp->temp = 50.0;
        temp->lowtemp = 51.1;
        temp->hightemp = 52.2;
        temp->scale = 'F';
        formatQuery(temp, result);

        // Split the string cause it's easier to match than a complex regex
        boost::split(items, result, boost::is_any_of(","));
        if (items[0] == "'67C6697351FF'"
            && items[1] == " 50.000000"
            && items[2] == " 52.200001"
            && items[3] == " 51.099998"
            && items[4] == " 'F'"
        ) {
            runtest.pass("formatQuery(temperature_t)");
        } else {
            runtest.fail("formatQuery(temperature_t)");
        }        
        
        // Reset the output buffer and test formatting a temperature entry
        result.clear();
        
        // id | current | volts | timestamp
        boost::shared_ptr<battery_t> batt(new battery_t);
        batt->id = "4AEC29CDBAAB";
        batt->current = 2.3;
        batt->volts = 14.3;
        batt->DC = true;

        formatQuery(batt, result);

        // Split the string cause it's easier to match than a complex regex
        items.clear();
        boost::split(items, result, boost::is_any_of(","));
        if (items[0] == "'4AEC29CDBAAB'"
            && items[1] == " 2.300000"
            && items[2] == " 14.300000"
            && items[3] == " 'DC'"
        ) {
            runtest.pass("formatQuery(battery_t)");
        } else {
            runtest.fail("formatQuery(battery_t)");
        }        
    };
    
    ~Test() {};
};

int
main(int argc, char *argv[])
{
    int c;
    bool dump = false;
    char buffer[300];
    std::string filespec;
    
    int retries = 3;

    memset(buffer, 0, 300);
    
    while ((c = getopt (argc, argv, "hdvsm:")) != -1) {
        switch (c) {
          case 'h':
            usage ();
            break;
            
          case 'd':
            dump = true;
            break;
            
          case 's':
            waitforgdb = true;
            break;
                                                                                
          case 'v':
            verbosity++;
            break;
            
          default:
            usage ();
            break;
        }
    }
    
    Test test;
}

static void
usage (void)
{
    std::cerr << "This program tests the XML processing code." << std::endl;
    std::cerr << "Usage: ./xml [h]" << std::endl;
    std::cerr << "-h\tHelp" << std::endl;
    std::cerr << "-d\tDump parsed data" << std::endl;
    exit (-1);
}

