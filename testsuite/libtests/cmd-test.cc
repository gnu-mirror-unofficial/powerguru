// 
//   Copyright (C) 2018 Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <unistd.h>
#include <vector>
#include "dejagnu.h"
#include "xml.h"
#include "commands.h"

int verbosity;
static void usage (void);
bool waitforgdb = false;

TestState runtest;

// Declare a class inherited from the base class so we can access the internal
// protected data.
class Test : public Commands
{
public:
    Test() {
        DEBUGLOG_REPORT_FUNCTION;

        // Test creating commands

        if (convertAction("nop") == Commands::NOP) {
            runtest.pass("convertAction(nop)");
        } else {
            runtest.fail("convertAction(nop)");
        }
        if (convertAction("list") == Commands::LIST) {
            runtest.pass("convertAction(list)");
        } else {
            runtest.fail("convertAction(list)");
        }
        if (convertAction("poll") == Commands::POLL) {
            runtest.pass("convertAction(poll)");
        } else {
            runtest.fail("convertAction(poll)");
        }
        if (convertAction("helo") == Commands::HELO) {
            runtest.pass("convertAction(helo)");
        } else {
            runtest.fail("convertAction(helo)");
        }
        
        std::string str;
        createCommand(Commands::HELO, "localhost enduser", str);
        if (str == "<command><helo><hostname>localhost</hostname><user>enduser</user></helo></command>\n") {
            runtest.pass("create HELO command");
        } else {
            runtest.fail("create HELO command");
        }
        str.erase();
        createCommand(Commands::NOP, "", str);
        if (str == "<command><nop></nop></command>\n") {
            runtest.pass("create NOP command");
        } else {
            runtest.fail("create NOP command");
        }
        str.erase();
        //
        createCommand(Commands::LIST, "foo", str);
        if (str == "<command><list>foo</list></command>\n") {
            runtest.pass("create LIST command");
        } else {
            runtest.fail("create LIST command");
        }
        str.erase();
        createCommand(Commands::POLL, "bar", str);
        if (str == "<command><poll>bar</poll></command>\n") {
            runtest.pass("create POLL command");
        } else {
            runtest.fail("create POLL command");
        }
        str.erase();

        // Test parsing XML commands
        XML xml;
        std::string testnop = "<command></command>\n";
        if (!xml.parseMem(testnop)) {
            runtest.untested("XML::parseMem(nop command) failed!");
        }
        if (xml.nameGet() == "command") {
            runtest.pass("parse NOP command");
        } else {
            runtest.fail("parse NOP command");
        }
        if (xml[0] == 0) {
            runtest.pass("NOP command has no children");
        } else {
            runtest.fail("NOP command has no children");
        }
        str.erase();

        std::string testlist = "<command><list>foo</list></command>\n";
        if (!xml.parseMem(testlist)) {
            runtest.untested("XML::parseMem(list command) failed!");
        }
        XMLNode *node = xml[0];
        if (node->nameGet() == "list") {
            runtest.pass("parse LIST command");
        } else {
            runtest.fail("parse LIST command");
        }
        str.erase();

        if (xml[0] != 0) {
            runtest.pass("LIST command has children");
        } else {
            runtest.fail("LIST command has children");
        }
        
        if (xml[0]->nameGet() == "list" && xml[0]->valueGet() == "foo") {
            runtest.pass("LIST command has correct child");
        } else {
            runtest.fail("LIST command has correct child");
        }
        
        //execCommand(xml, str);        
        
        std::string testpoll = "<command><poll>bar</poll></command>\n";
        if (!xml.parseMem(testpoll)) {
            runtest.untested("XML::parseMem(poll command) failed!");
        }
        node = xml[0];
        if (node->nameGet() == "poll") {
            runtest.pass("parse POLL command");
        } else {
            runtest.fail("parse POLL command");
        }
        str.erase();

        if (xml[0] != 0) {
            runtest.pass("POLL command has children");
        } else {
            runtest.fail("POLL command has children");
        }
        
        if (xml[0]->nameGet() == "poll" && xml[0]->valueGet() == "bar") {
            runtest.pass("POLL command has correct child");
        } else {
            runtest.fail("POLL command has correct child");
        }

        std::string testhelo = "<command><helo><hostname>localhost</hostname><user>enduser</user></helo></command>\n";
        if (!xml.parseMem(testhelo)) {
            runtest.untested("XML::parseMem(helo command) failed!");
        }
        node = xml[0];
        if (node->nameGet() == "helo") {
            runtest.pass("parse helo command");
        } else {
            runtest.fail("parse helo command");
        }
        str.erase();
        // This top level node has two children
        if (node->childGet(0)->nameGet() == "hostname"
            && node->childGet(0)->valueGet() == "localhost"
            && node->childGet(1)->valueGet() == "enduser"
            && node->childGet(1)->nameGet() == "user") {
            runtest.pass("HELO command has both children");
        } else {
            runtest.fail("HELO command has both children");
        }  
    };

    ~Test() {};
};

int
main(int argc, char *argv[])
{
    int c;
    bool dump = false;
    char buffer[300];
    std::string filespec;
    
    int retries = 3;

    memset(buffer, 0, 300);
    
    while ((c = getopt (argc, argv, "hdvsm:")) != -1) {
        switch (c) {
          case 'h':
            usage ();
            break;
            
          case 'd':
            dump = true;
            break;
            
          case 's':
            waitforgdb = true;
            break;
                                                                                
          case 'v':
            verbosity++;
            break;
            
          default:
            usage ();
            break;
        }
    }
    
    // get the file name from the command line
    if (optind < argc) {
        filespec = argv[optind];
        std::cout << "Will use \"" << filespec << "\" for test " << std::endl;
    }

    Test test;
}

void
cntrlc_handler (int sig)
{
    std::cerr << "Got a ^C !" << std::endl;
}

void
alarm_handler (int sig)
{
    std::cerr << "Got an alarm signal !" << std::endl;
    std::cerr << "This is OK, we use it to end this test case." << std::endl;
}

static void
usage (void)
{
    std::cerr << "This program tests the XML processing code." << std::endl;
    std::cerr << "Usage: ./xml [h]" << std::endl;
    std::cerr << "-h\tHelp" << std::endl;
    std::cerr << "-d\tDump parsed data" << std::endl;
    exit (-1);
}

