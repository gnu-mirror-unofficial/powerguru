// 
//   Copyright (C) 2005, 2006-2018
//   Free Software Foundation, Inc.
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdarg.h>
#include <signal.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <cstdio>
#include <iostream>
#include <netdb.h>
#include <sys/utsname.h>

#include "dejagnu.h"

#include "tcputil.h"
#include "tcpip.h"

using namespace std;

int verbosity;
static void usage (void);

TestState runtest;
const short DEFAULTPORT  = 7654;

class Test : public Tcputil
{
public:
    Test(void) {
        // Get some system information needed to test the classes.
        std::memset(_thost, 0, MAXHOSTNAMELEN);
        if (gethostname(_thost, MAXHOSTNAMELEN) != 0) {
            std::cerr << "ERROR: gethostname() failed!" << std::endl;
            exit(-1);
        }
        
        if (_thost == 0) {
            std::cerr << "ERROR: gethostbyname() failed!" << std::endl;
            exit(-1);        
        }
        
        _tservice = getservbyname("git", NULL);
        if (_tservice == 0) {
            std::cerr << "ERROR: getservbyname() failed!" << std::endl;
            exit(-1);        
        }
    };
    
    int test(void) {
        if (numberOfInterfaces() >= 2) {
            runtest.pass ("Tcputil::numberOfInterfaces()");
        } else {
            runtest.fail ("Tcputil::numberOfInterfaces()");  
        }

        // Check the defaults
        if (_hostname != _thost && _hostname == "localhost") {
            runtest.pass ("Hostname is correct");
        } else {
            runtest.fail ("Hostname is not correct");
        }

        if (_service == 0) {
            runtest.pass ("Service is correctly empty");
        } else {
            runtest.unresolved ("Service is not correctly empty");
        }
        
        // See if we can do service lookups
        struct servent *serv = lookupService("ftp", "tcp");
        
        if (strcmp(serv->s_name, "ftp") == 0 &&
            strcmp(serv->s_proto, "tcp") == 0 &&
            serv->s_port == ntohs(21)) {
            runtest.pass ("Tcputil::lookupService(ftp)");
        } else {
            runtest.fail ("Tcputil::lookupService(ftp)");
        }

        struct addrinfo *addr;
        if (addr = getAddrInfo()) {
            runtest.pass ("Tcputil::getAddrInfo()");
        } else {
            runtest.fail ("Tcputil::getAddrInfo()");
        }

        std::string str;
        if (printIP(addr, str) == "127.0.0.1") {
            runtest.pass ("Tcputil::printIP()");
        } else {
            runtest.fail ("Tcputil::printIP()");
        }

        if (addr = getAddrInfo("gnu.org")) {
            runtest.pass ("Tcputil::getAddrInfo(gnu.org)");
        } else {
            runtest.fail ("Tcputil::getAddrInfo(gnu.org)");
        }
        
        dump();
    };
    
    ~Test(void) {
    };
    
protected:
    char                   _thost[MAXHOSTNAMELEN];
    const struct servent  *_tservice;
    const struct protoent *_tproto;
    const in_addr_t       *_taddr;
};

int
main(int argc, char *argv[])
{
    int c;
    bool dump = false;
    string filespec;
    string procname, memname;
    
    while ((c = getopt (argc, argv, "hdv")) != -1) {
        switch (c) {
          case 'h':
            usage ();
            break;
            
          case 'd':
            dump = true;
            break;
            
          case 'v':
            verbosity++;
            break;
            
          default:
            usage ();
            break;
        }
    }
    
    // get the file name from the command line
    if (optind < argc) {
        filespec = argv[optind];
        cout << "Will use \"" << filespec << "\" for test " << endl;
    }

    Test test;
    test.test();    
}

static void
usage (void)
{
    cerr << "This program tests the Global memory system." << endl;
    cerr << "Usage: tcputil [h] filename" << endl;
    cerr << "-h\tHelp" << endl;
    cerr << "-d\tDump parsed data" << endl;
    exit (-1);
}
